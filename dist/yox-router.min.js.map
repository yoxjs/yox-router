{"version":3,"file":"yox-router.min.js","sources":["../src/constant.ts","../src/Hooks.ts","../src/util/value.ts","../src/mode/history.ts","../src/mode/hash.ts","../src/Router.ts","../src/util/query.ts"],"sourcesContent":["export const WINDOW = window\n\nexport const LOCATION = WINDOW.location\n\nexport const HISTORY = WINDOW.history\n\nexport const UNDEFINED = void 0\n\nexport const NULL = null\n\nexport const TRUE = true\n\nexport const FALSE = false\n\nexport const RAW_NULL = 'null'\n\nexport const RAW_TRUE = 'true'\n\nexport const RAW_FALSE = 'false'\n\n// path 中的参数前缀，如 /user/:userId\nexport const PREFIX_PARAM = ':'\n\n// path 分隔符\nexport const SEPARATOR_PATH = '/'\n\n// path 和 search 的分隔符\nexport const SEPARATOR_SEARCH = '?'\n\n// query 分隔符\nexport const SEPARATOR_QUERY = '&'\n\n// 键值对分隔符\nexport const SEPARATOR_PAIR = '='\n\n// 参数中的数组标识\nexport const FLAG_ARRAY = '[]'\n\n// history 模式\nexport const MODE_HISTORY = 'history'\n\n// 导航钩子 - 路由进入之前\nexport const ROUTER_HOOK_BEFORE_ENTER = 'beforeEnter'\n\n// 导航钩子 - 路由进入之后\nexport const ROUTER_HOOK_AFTER_ENTER = 'afterEnter'\n\n// 导航钩子 - 路由更新之前\nexport const ROUTER_HOOK_BEFORE_UPDATE = 'beforeUpdate'\n\n// 导航钩子 - 路由更新之后\nexport const ROUTER_HOOK_AFTER_UPDATE = 'afterUpdate'\n\n// 导航钩子 - 路由离开之前\nexport const ROUTER_HOOK_BEFORE_LEAVE = 'beforeLeave'\n\n// 导航钩子 - 路由离开之后\nexport const ROUTER_HOOK_AFTER_LEAVE = 'afterLeave'\n\n// 组件 Options 上的导航钩子\nexport const COMPONENT_HOOK_BEFORE_ENTER = 'beforeRouteEnter'\nexport const COMPONENT_HOOK_AFTER_ENTER = 'afterRouteEnter'\nexport const COMPONENT_HOOK_BEFORE_UPDATE = 'beforeRouteUpdate'\nexport const COMPONENT_HOOK_AFTER_UPDATE = 'afterRouteUpdate'\nexport const COMPONENT_HOOK_BEFORE_LEAVE = 'beforeRouteLeave'\nexport const COMPONENT_HOOK_AFTER_LEAVE = 'afterRouteLeave'","import {\n  Task,\n} from 'yox'\n\nimport {\n  Location,\n} from './type'\n\nexport default class Hooks {\n\n  list: Task[]\n\n  to: Location\n\n  from: Location | void\n\n  setLocation(to: Location, from: Location | void) {\n    this.to = to\n    this.from = from\n    return this\n  }\n\n  clear() {\n    this.list = []\n    return this\n  }\n\n  add(hook: Function | void, ctx: any) {\n    const { list } = this\n    if (hook) {\n      list.push({\n        fn: hook,\n        ctx,\n      })\n    }\n    return this\n  }\n\n  next(isGuard: boolean, next: Function, callback: Function) {\n    const task = this.list.shift()\n    if (task) {\n      if (isGuard) {\n        task.fn.call(task.ctx, this.to, this.from, next)\n      }\n      else {\n        task.fn.call(task.ctx, this.to, this.from)\n        next()\n      }\n    }\n    else {\n      callback()\n    }\n  }\n\n}","import Yox from 'yox'\n\nimport {\n  NULL,\n  TRUE,\n  FALSE,\n  RAW_NULL,\n  RAW_TRUE,\n  RAW_FALSE,\n} from '../constant'\n\n/**\n * 把字符串 value 解析成最合适的类型\n */\nexport function parse(value: string) {\n  let result: any\n  if (Yox.is.numeric(value)) {\n    result = +value\n  }\n  else if (Yox.is.string(value)) {\n    if (value === RAW_TRUE) {\n      result = TRUE\n    }\n    else if (value === RAW_FALSE) {\n      result = FALSE\n    }\n    else if (value === RAW_NULL) {\n      result = NULL\n    }\n    else {\n      result = decodeURIComponent(value)\n    }\n  }\n  return result\n}\n\nexport function stringify(value: any): string | void {\n  if (Yox.is.string(value)) {\n    return encodeURIComponent(value)\n  }\n  else if (Yox.is.number(value) || Yox.is.boolean(value)) {\n    return value.toString()\n  }\n  else if (value === NULL) {\n    return RAW_NULL\n  }\n}","import Yox, {\n  Listener,\n} from 'yox'\n\nimport {\n  Location,\n} from '../type'\n\nimport {\n  WINDOW,\n  HISTORY,\n  LOCATION,\n} from '../constant'\n\nconst POP_STATE = 'popstate'\n\nexport const isSupported = 'pushState' in HISTORY\n\nexport function start(handler: Function) {\n  Yox.dom.on(WINDOW, POP_STATE, handler as Listener)\n  handler()\n}\n\nexport function stop(handler: Function) {\n  Yox.dom.off(WINDOW, POP_STATE, handler)\n}\n\nexport function push(location: Location, handler: Function) {\n  // 调用 pushState 不会触发 popstate 事件\n  // 因此这里需要手动调用一次 handler\n  HISTORY.pushState({}, '', location.url)\n  handler()\n}\n\nexport function replace(location: Location, handler: Function) {\n  // 调用 replaceState 不会触发 popstate 事件\n  // 因此这里需要手动调用一次 handler\n  replaceState(location.url as string, handler)\n}\n\nexport function go(n: number) {\n  HISTORY.go(n)\n}\n\nexport function current() {\n  return LOCATION.pathname + LOCATION.search\n}\n\nexport function replaceState(url: string, handler: Function) {\n\n  // try...catch the pushState call to get around Safari\n  // DOM Exception 18 where it limits to 100 pushState calls\n  try {\n    HISTORY.replaceState({}, '', url)\n    handler()\n  }\n  catch (e) {\n    LOCATION.replace(url)\n  }\n\n}","import Yox, {\n  Listener,\n} from 'yox'\n\nimport {\n  Location,\n} from '../type'\n\nimport {\n  WINDOW,\n  HISTORY,\n  LOCATION,\n  SEPARATOR_PATH,\n} from '../constant'\n\nimport {\n  isSupported,\n  replaceState,\n} from './history'\n\n// hash 前缀，Google 的规范是 #! 开头，如 #!/path/sub?key=value\nconst HASH_PREFIX = '#!',\n\nHASH_CHANGE = 'hashchange'\n\nexport function start(handler: Function) {\n  Yox.dom.on(WINDOW, HASH_CHANGE, handler as Listener)\n  handler()\n}\n\nexport function stop(handler: Function) {\n  Yox.dom.off(WINDOW, HASH_CHANGE, handler)\n}\n\nexport function push(location: Location, handler: Function) {\n  LOCATION.hash = HASH_PREFIX + location.url\n}\n\nexport function replace(location: Location, handler: Function) {\n\n  const url = LOCATION.protocol + '//' + LOCATION.host + LOCATION.pathname + HASH_PREFIX + location.url\n\n  if (isSupported) {\n    replaceState(url, handler)\n  }\n  else {\n    LOCATION.replace(url)\n  }\n\n}\n\nexport function go(n: number) {\n  HISTORY.go(n)\n}\n\nexport function current() {\n\n  // 不能直接读取 window.location.hash\n  // 因为 Firefox 会做 pre-decode\n  const href = LOCATION.href, index = href.indexOf(HASH_PREFIX)\n\n  return index > 0\n    ? href.substr(index + HASH_PREFIX.length)\n    : SEPARATOR_PATH\n\n}\n","import Yox, {\n  Data,\n  Listener,\n  VNode,\n  Directive,\n  ComponentOptions,\n  CustomEventInterface,\n  YoxInterface,\n} from 'yox'\n\nimport {\n  TRUE,\n  FALSE,\n  UNDEFINED,\n\n  MODE_HISTORY,\n  PREFIX_PARAM,\n  SEPARATOR_PATH,\n  SEPARATOR_SEARCH,\n\n  ROUTER_HOOK_BEFORE_ENTER,\n  ROUTER_HOOK_AFTER_ENTER,\n  ROUTER_HOOK_BEFORE_UPDATE,\n  ROUTER_HOOK_AFTER_UPDATE,\n  ROUTER_HOOK_BEFORE_LEAVE,\n  ROUTER_HOOK_AFTER_LEAVE,\n\n  COMPONENT_HOOK_BEFORE_ENTER,\n  COMPONENT_HOOK_AFTER_ENTER,\n  COMPONENT_HOOK_BEFORE_UPDATE,\n  COMPONENT_HOOK_AFTER_UPDATE,\n  COMPONENT_HOOK_BEFORE_LEAVE,\n  COMPONENT_HOOK_AFTER_LEAVE,\n} from './constant'\n\nimport {\n  Target,\n  Location,\n  RouteTarget,\n  RouterOptions,\n  RouteOptions,\n  LinkedRoute,\n  RoutePending,\n  Redirect,\n  RouteCallback,\n  RouterMode,\n  RouteBeforeHook,\n  RouteAfterHook,\n} from './type'\n\nimport Hooks from './Hooks'\n\nimport * as queryUtil from './util/query'\nimport * as valueUtil from './util/value'\n\nimport * as hashMode from './mode/hash'\nimport * as historyMode from './mode/history'\n\nlet hookEvents: Record<string, Listener>, guid = 0\n\nconst ROUTE_COMPONENT = 'RouteComponent',\n\nNAMESPACE_HOOK = '.hook',\n\nEVENT_CLICK = 'click'\n\n/**\n * 格式化路径，确保它以 / 开头，不以 / 结尾\n */\nfunction formatPath(path: string, parentPath: string | void) {\n\n  // 如果不是 / 开头，表示是相对路径\n  if (!Yox.string.startsWith(path, SEPARATOR_PATH)) {\n    // 确保 parentPath 以 / 结尾\n    if (parentPath) {\n      if (!Yox.string.endsWith(parentPath, SEPARATOR_PATH)) {\n        parentPath += SEPARATOR_PATH\n      }\n    }\n    else {\n      parentPath = SEPARATOR_PATH\n    }\n    path = parentPath + path\n  }\n\n  // 如果 path 以 / 结尾，删掉它\n  if (path !== SEPARATOR_PATH\n    && Yox.string.endsWith(path, SEPARATOR_PATH)\n  ) {\n    path = Yox.string.slice(path, 0, -SEPARATOR_PATH.length)\n  }\n\n  return path\n\n}\n\n/**\n * 把结构化数据序列化成 url\n */\nfunction stringifyUrl(path: string, params: Data | void, query: Data | void) {\n\n  if (/\\/\\:\\w+/.test(path)) {\n\n    const terms: string[] = []\n\n    Yox.array.each(\n      path.split(SEPARATOR_PATH),\n      function (item) {\n        terms.push(\n          Yox.string.startsWith(item, PREFIX_PARAM) && params\n            ? params[item.substr(PREFIX_PARAM.length)]\n            : item\n        )\n      }\n    )\n\n    path = terms.join(SEPARATOR_PATH)\n\n  }\n\n  if (query) {\n    const queryStr = queryUtil.stringify(query)\n    if (queryStr) {\n      path += SEPARATOR_SEARCH + queryStr\n    }\n  }\n\n  return path\n\n}\n\n/**\n * 按照 propTypes 定义的外部数据格式过滤路由参数，这样有两个好处：\n *\n * 1. 避免传入不符预期的数据\n * 2. 避免覆盖 data 定义的数据\n */\nfunction filterProps(route: LinkedRoute, location: Location, options: ComponentOptions) {\n  const result: Data = {}, propTypes = options.propTypes\n  if (propTypes) {\n\n    let props = location.query,\n\n    routeParams = route.params,\n\n    locationParams = location.params\n\n    // 从 location.params 挑出 route.params 定义过的参数\n    if (routeParams && locationParams) {\n      props = props ? Yox.object.copy(props) : {}\n      for (let i = 0, length = routeParams.length; i < length; i++) {\n        (props as Data)[routeParams[i]] = locationParams[routeParams[i]]\n      }\n    }\n\n    if (props) {\n      for (let key in propTypes) {\n        let value = props[key]\n        if (value !== UNDEFINED) {\n          result[key] = value\n        }\n      }\n    }\n\n  }\n  return result\n}\n\n/**\n * 是否是叶子节点\n * 如果把叶子节点放在 if 中，会出现即使不是定义时的叶子节点，却是运行时的叶子节点\n */\nfunction isLeafRoute(route: LinkedRoute) {\n  const child = route.child\n  return !child || !child.context\n}\n\nfunction updateRoute(instance: YoxInterface, componentHookName: string | void, routerHookName: string | undefined, upsert?: boolean) {\n  const route = instance.$route as LinkedRoute\n  if (route) {\n    route.context = upsert ? instance : UNDEFINED\n    if (isLeafRoute(route)) {\n      const router = instance.$router as Router\n      if (componentHookName && routerHookName) {\n        router.hook(route, componentHookName, routerHookName, FALSE)\n      }\n      if (upsert) {\n        const { pending } = router\n        if (pending) {\n          pending.onComplete()\n          router.pending = UNDEFINED\n        }\n      }\n    }\n  }\n}\n\nexport class Router {\n\n  el: Element\n\n  options: RouterOptions\n\n  routes: LinkedRoute[]\n\n  route404: LinkedRoute\n\n  name2Path: Record<string, string>\n\n  path2Route: Record<string, LinkedRoute>\n\n  mode: RouterMode\n\n  pending?: RoutePending\n\n  // 路由钩子\n  hooks: Hooks\n\n  // 路由或参数发生了变化会触发此函数\n  handler: Function\n\n  // 当前渲染的路由\n  route?: LinkedRoute\n\n  // 当前地址栏的路径和参数\n  location?: Location\n\n  constructor(options: RouterOptions) {\n\n    const instance = this, el = options.el, route404 = options.route404 || default404\n\n    instance.options = options\n\n    instance.el = Yox.is.string(el)\n      ? Yox.dom.find(el as string) as Element\n      : el as Element\n\n    if (process.env.NODE_ENV === 'development') {\n      if (!instance.el) {\n        Yox.logger.error(`The \"el\" option must be an element or a selector.`)\n        return\n      }\n    }\n\n    instance.mode = options.mode === MODE_HISTORY && historyMode.isSupported\n      ? historyMode\n      : hashMode\n\n    instance.handler = function () {\n\n      // 从地址栏读取最新 url\n      instance.parseLocation(\n        instance.mode.current(),\n        function (location) {\n          if (location) {\n            instance.setRoute(location)\n          }\n          else {\n            instance.push(instance.route404)\n          }\n        }\n      )\n\n    }\n\n    instance.routes = []\n    instance.name2Path = {}\n    instance.path2Route = {}\n\n    instance.hooks = new Hooks()\n\n    Yox.array.each(\n      options.routes,\n      function (route) {\n        instance.add(route)\n      }\n    )\n\n    instance.route404 = instance.add(route404)[0]\n\n  }\n\n  /**\n   * 添加一个新的路由\n   */\n  add(routeOptions: RouteOptions, parentRoute: LinkedRoute | void) {\n\n    const instance = this,\n\n    newRoutes: LinkedRoute[] = [],\n\n    pathStack: string[] = [],\n\n    routeStack: LinkedRoute[] = [],\n\n    addRoute = function (routeOptions: RouteOptions) {\n\n      let { name, component, children, load } = routeOptions,\n\n      parentPath = Yox.array.last(pathStack),\n\n      parentRoute = Yox.array.last(routeStack),\n\n      path = formatPath(routeOptions.path, parentPath),\n\n      route: LinkedRoute = { path, route: routeOptions },\n\n      params: string[] = []\n\n      Yox.array.each(\n        path.split(SEPARATOR_PATH),\n        function (item) {\n          if (Yox.string.startsWith(item, PREFIX_PARAM)) {\n            params.push(\n              item.substr(PREFIX_PARAM.length)\n            )\n          }\n        }\n      )\n\n      if (params.length) {\n        route.params = params\n      }\n\n      if (name) {\n        route.name = name\n      }\n\n      // component 和 load 二选一\n      if (load) {\n        route.load = load\n      }\n      else {\n        // 每一级都必须有一个组件\n        // 如果没有，则用占位组件，避免业务层写太多无用的组件\n        route.component = component || placeholderComponent\n      }\n\n      if (parentRoute) {\n        route.parent = parentRoute\n      }\n\n      if (children) {\n        pathStack.push(path)\n        routeStack.push(route)\n        Yox.array.each(\n          children,\n          addRoute\n        )\n        routeStack.pop()\n        pathStack.pop()\n      }\n      else {\n\n        newRoutes.push(route)\n        instance.routes.push(route)\n\n        if (name) {\n          if (process.env.NODE_ENV === 'development') {\n            if (Yox.object.has(instance.name2Path, name)) {\n              Yox.logger.error(`The name \"${name}\" of the route is existed.`)\n              return\n            }\n          }\n          instance.name2Path[name] = path\n        }\n\n        if (process.env.NODE_ENV === 'development') {\n          if (Yox.object.has(instance.path2Route, path)) {\n            Yox.logger.error(`The path \"${path}\" of the route is existed.`)\n            return\n          }\n        }\n\n        instance.path2Route[path] = route\n\n      }\n\n    }\n\n    if (parentRoute) {\n      pathStack.push(parentRoute.path)\n      routeStack.push(parentRoute)\n    }\n\n    addRoute(routeOptions)\n\n    return newRoutes\n\n  }\n\n  /**\n   * 删除一个已注册的路由\n   */\n  remove(route: LinkedRoute) {\n\n    const instance = this\n\n    Yox.array.remove(instance.routes, route)\n\n    if (route.name) {\n      delete instance.name2Path[route.name]\n    }\n\n    delete instance.path2Route[route.path]\n\n  }\n\n  /**\n   * target 有 3 种格式：\n   *\n   * 如果只是简单的 path，直接传字符串\n   *\n   * push('/index')\n   *\n   * 如果需要带参数，可传对象\n   *\n   * push({\n   *   path: '/index',\n   *   params: { },\n   *   query: { }\n   * })\n   *\n   * 如果路由配置了 name，可用 name 代替 path，如下：\n   *\n   * push({\n   *   name: 'index'\n   * })\n   *\n   * 也可以不传 path 或 name，只传 params 或 query\n   * 表示不修改 path，仅修改 params 或 query\n   *\n   */\n  push(target: Target) {\n\n    const instance = this, { mode } = instance\n\n    instance.setUrl(\n      instance.toUrl(target),\n      function (location) {\n        if (mode.current() !== location.url) {\n          mode.push(location, instance.handler)\n        }\n      }\n    )\n\n  }\n\n  /**\n   * 替换当前路由栈\n   */\n  replace(target: Target) {\n\n    const instance = this, { mode } = instance\n\n    instance.setUrl(\n      instance.toUrl(target),\n      function (location) {\n        if (mode.current() !== location.url) {\n          mode.replace(location, instance.handler)\n        }\n      }\n    )\n\n  }\n\n  /**\n   * 前进或后退 n 步\n   */\n  go(n: number) {\n    this.mode.go(n)\n  }\n\n  /**\n   * 启动路由\n   */\n  start() {\n    this.mode.start(this.handler)\n  }\n\n  /**\n   * 停止路由\n   */\n  stop() {\n    this.mode.stop(this.handler)\n  }\n\n  /**\n   * 钩子函数\n   */\n  hook(route: LinkedRoute, componentHook: string, routerHook: string, isGuard: boolean, callback?: Function) {\n\n    const instance = this,\n\n    { location, hooks, pending } = instance,\n\n    { context } = route,\n\n    onComplete = function () {\n      // 如果钩子未被拦截，则会走进 onComplete\n      // 这里要把钩子事件冒泡上去，便于业务层处理\n      // 加命名空间是为了和 yox 生命周期钩子事件保持一致\n      if (context) {\n        context.fire(\n          componentHook + NAMESPACE_HOOK,\n          {\n            from: hooks.from,\n            to: hooks.to,\n          }\n        )\n      }\n      // 在发事件之后调用 callback\n      // 因为 callback 有可能销毁组件，导致事件发不出去\n      if (callback) {\n        callback()\n      }\n    },\n\n    next = function (value?: false | Target) {\n      if (value === UNDEFINED) {\n        hooks.next(isGuard, next, onComplete)\n      }\n      else {\n        // 只有前置守卫才有可能走进这里\n        // 此时 instance.location 还是旧地址\n        if (pending) {\n          pending.onAbort()\n          instance.pending = UNDEFINED\n        }\n        if (value === FALSE) {\n          if (location) {\n            instance.push(location)\n          }\n        }\n        else {\n          // 跳转到别的路由\n          instance.push(value)\n        }\n      }\n    }\n\n    hooks\n      .clear()\n      // 先调用组件的钩子\n      .add((route.component as ComponentOptions)[componentHook], context)\n      // 再调用路由配置的钩子\n      .add(route.route[routerHook], route.route)\n      // 最后调用路由实例的钩子\n      .add(instance.options[routerHook], instance)\n\n    next()\n\n  }\n\n  private toUrl(target: Target): string {\n\n    if (Yox.is.string(target)) {\n      return formatPath(target as string)\n    }\n\n    let instance = this,\n\n    location = instance.location,\n\n    routeTarget = target as RouteTarget,\n\n    params = routeTarget.params,\n\n    path: string | void\n\n    if (routeTarget.name) {\n      path = instance.name2Path[routeTarget.name]\n    }\n    else if (routeTarget.path) {\n      path = formatPath(routeTarget.path)\n    }\n    else if (location) {\n      path = location.path\n      if (!params) {\n        params = location.params\n      }\n    }\n\n    if (process.env.NODE_ENV === 'development') {\n      if (!Yox.is.string(path)) {\n        Yox.logger.error(`The path is not found.`)\n      }\n    }\n\n    return stringifyUrl(\n      path as string,\n      params,\n      routeTarget.query\n    )\n\n  }\n\n  private setUrl(url: string, callback: (locaiton: Location) => void) {\n\n    // 这里无需判断新旧 url 是否相同，因为存在 replace，即使它们相同也不等价于不用跳转\n    const instance = this\n\n    instance.parseLocation(\n      url,\n      function (location) {\n        if (location) {\n          callback(location)\n        }\n      }\n    )\n\n  }\n\n  private parseLocation(url: string, callback: (location?: Location) => void) {\n\n    let realpath: string, search: string | void, index = url.indexOf(SEPARATOR_SEARCH)\n\n    if (index >= 0) {\n      realpath = url.slice(0, index)\n      search = url.slice(index + 1)\n    }\n    else {\n      realpath = url\n    }\n\n    // 匹配已注册的 route\n    const instance = this,\n\n    realpathTerms = realpath.split(SEPARATOR_PATH),\n\n    length = realpathTerms.length,\n\n    matchRoute = function (\n      routes: LinkedRoute[],\n      callback: (route?: LinkedRoute, params?: Data) => void\n    ) {\n\n      let index = 0, route: LinkedRoute | void\n\n      loop: while (route = routes[index++]) {\n        const path = route.path\n\n        // 动态路由\n        if (route.params) {\n          const pathTerms = path.split(SEPARATOR_PATH)\n          // path 段数量必须一致，否则没有比较的意义\n          if (length === pathTerms.length) {\n            const params: Data = {}\n            for (let i = 0; i < length; i++) {\n              if (Yox.string.startsWith(pathTerms[i], PREFIX_PARAM)) {\n                params[pathTerms[i].substr(PREFIX_PARAM.length)] = valueUtil.parse(realpathTerms[i])\n              }\n              // 非参数段不相同\n              else if (pathTerms[i] !== realpathTerms[i]) {\n                continue loop\n              }\n            }\n            callback(route, params)\n            return\n          }\n        }\n        // 懒加载路由，前缀匹配成功后，意味着懒加载回来的路由一定有我们想要的\n        else if (route.load && Yox.string.startsWith(realpath, path)) {\n          const routeCallback: RouteCallback = function (lazyRoute) {\n            instance.remove(route as LinkedRoute)\n            matchRoute(\n              instance.add(lazyRoute['default'] || lazyRoute, (route as LinkedRoute).parent),\n              callback\n            )\n          }\n          const promise = route.load(routeCallback)\n          if (promise) {\n            promise.then(routeCallback)\n          }\n          return\n        }\n        else if (path === realpath) {\n          callback(route)\n          return\n        }\n      }\n\n      callback()\n\n    }\n\n    matchRoute(\n      instance.routes,\n      function (route, params) {\n        if (route) {\n          const location: Location = {\n            url,\n            path: route.path\n          }\n          if (params) {\n            location.params = params\n          }\n          if (search) {\n            const query = queryUtil.parse(search)\n            if (query) {\n              location.query = query\n            }\n          }\n          callback(location)\n        }\n        else {\n          if (process.env.NODE_ENV === 'development') {\n            Yox.logger.error(`The path \"${realpath}\" can't match a route.`)\n          }\n          callback()\n        }\n      }\n    )\n\n  }\n\n  private diffRoute(\n    route: LinkedRoute,\n    oldRoute: LinkedRoute | void,\n    onComplete: (route: LinkedRoute, startRoute: LinkedRoute | void) => void,\n    startRoute: LinkedRoute | void,\n    childRoute: LinkedRoute | void,\n    oldTopRoute: LinkedRoute | void\n  ) {\n\n    // 更新链路\n    if (childRoute) {\n      route.child = childRoute\n      childRoute.parent = route\n    }\n\n    if (oldRoute) {\n      // 同级的两个组件不同，疑似起始更新的路由\n      if (oldRoute.component !== route.component) {\n        startRoute = route\n      }\n      else {\n        // 把上次的组件实例搞过来\n        route.context = oldRoute.context\n      }\n    }\n    else {\n      startRoute = route\n    }\n\n    if (route.parent) {\n      this.diffRoute(\n        Yox.object.copy(route.parent),\n        oldRoute ? oldRoute.parent : UNDEFINED,\n        onComplete,\n        startRoute,\n        route,\n        oldRoute || oldTopRoute\n      )\n      return\n    }\n\n    // 整个组件树全换掉\n    if (startRoute === route) {\n      let context: YoxInterface | void\n      // 当层级较多的路由切换到层级较少的路由\n      if (oldRoute) {\n        while (oldRoute) {\n          context = oldRoute.context\n          oldRoute = oldRoute.parent\n        }\n      }\n      // 当层级较少的路由切换到层级较多的路由\n      else if (oldTopRoute) {\n        context = oldTopRoute.context\n      }\n      if (context) {\n        startRoute.context = context\n      }\n    }\n\n    // 到达根组件，结束\n    onComplete(route, startRoute)\n\n  }\n\n  private patchRoute(\n    route: LinkedRoute,\n    startRoute: LinkedRoute | void\n  ) {\n\n    const instance = this, location = instance.location as Location\n\n    // 从上往下更新 props\n    while (route) {\n\n      let { parent, context, component } = route\n\n      if (route === startRoute) {\n\n        if (parent) {\n\n          context = parent.context as YoxInterface\n          context.forceUpdate(\n            filterProps(\n              parent,\n              location,\n              parent.component as ComponentOptions\n            )\n          )\n\n          context = context.$routeView\n          if (context) {\n            const props = {}, name = ROUTE_COMPONENT + (++guid)\n            props[ROUTE_COMPONENT] = name\n            context.component(name, component)\n            context.forceUpdate(props)\n          }\n\n        }\n        else {\n\n          if (context) {\n            context.destroy()\n          }\n\n          // 每层路由组件都有 $route 和 $router 属性\n          const extensions = {\n            $router: instance,\n            $route: route\n          }\n\n          const options: ComponentOptions = Yox.object.extend(\n            {\n              el: instance.el,\n              props: filterProps(route, location, component as ComponentOptions),\n              extensions,\n            },\n            component as ComponentOptions\n          )\n\n          options.events = options.events\n            ? Yox.object.extend(options.events, hookEvents)\n            : hookEvents\n\n          route.context = new Yox(options)\n\n        }\n\n      }\n\n      else if (context) {\n        if (context.$vnode) {\n          context.$route = route\n          context.forceUpdate(\n            filterProps(route, location, component as ComponentOptions)\n          )\n        }\n        else {\n          route.context = UNDEFINED\n        }\n        if (route.child) {\n          route = route.child as LinkedRoute\n          continue\n        }\n      }\n      break\n    }\n  }\n\n  private setRoute(location: Location) {\n\n    let instance = this,\n\n    linkedRoute = instance.path2Route[location.path],\n\n    redirect = linkedRoute.route.redirect\n\n    if (redirect) {\n      if (Yox.is.func(redirect)) {\n        redirect = (redirect as Redirect)(location)\n      }\n      if (redirect) {\n        instance.push(redirect as Target)\n        return\n      }\n    }\n\n    const newRoute = Yox.object.copy(linkedRoute),\n\n    oldRoute = instance.route,\n\n    oldLocation = instance.location,\n\n    enterRoute = function () {\n      instance.diffRoute(\n        newRoute,\n        oldRoute,\n        function (route, startRoute) {\n          instance.hook(\n            newRoute,\n            startRoute ? COMPONENT_HOOK_BEFORE_ENTER : COMPONENT_HOOK_BEFORE_UPDATE,\n            startRoute ? ROUTER_HOOK_BEFORE_ENTER : ROUTER_HOOK_BEFORE_UPDATE,\n            TRUE,\n            function () {\n\n              instance.route = newRoute\n              instance.location = location\n\n              instance.patchRoute(route, startRoute)\n\n            }\n          )\n        }\n      )\n    }\n\n    instance.hooks.setLocation(location, oldLocation)\n\n    if (oldRoute && oldLocation && location.path !== oldLocation.path) {\n      instance.hook(\n        oldRoute,\n        COMPONENT_HOOK_BEFORE_LEAVE,\n        ROUTER_HOOK_BEFORE_LEAVE,\n        TRUE,\n        enterRoute\n      )\n      return\n    }\n\n    enterRoute()\n\n  }\n\n}\n\nimport template404 from './template/404.hbs'\nimport templatePlaceholder from './template/Placeholder.hbs'\nimport templateRouterView from './template/RouterView.hbs'\n\nconst default404 = {\n  path: '/404',\n  component: {\n    template: template404\n  }\n},\n\n// 占位组件\nplaceholderComponent = {\n  template: templatePlaceholder\n},\n\ndirective = {\n  bind(node: HTMLElement | YoxInterface, directive: Directive, vnode: VNode) {\n\n    // 当前组件如果是根组件，则没有 $root 属性\n    const $root = vnode.context.$root || vnode.context,\n\n    router = $root.$router as Router,\n\n    listener = vnode.data[directive.key] = function (_: CustomEventInterface) {\n      let { value, getter } = directive, target: any = value\n      if (value && getter && Yox.string.has(value as string, '{')) {\n        target = getter()\n      }\n      router[directive.name](target)\n    }\n\n    if (vnode.isComponent) {\n      (node as YoxInterface).on(EVENT_CLICK, listener)\n    }\n    else {\n      Yox.dom.on(node as HTMLElement, EVENT_CLICK, listener)\n    }\n\n  },\n  unbind(node: HTMLElement | YoxInterface, directive: Directive, vnode: VNode) {\n    const listener = vnode.data[directive.key]\n    if (vnode.isComponent) {\n      (node as YoxInterface).off(EVENT_CLICK, listener)\n    }\n    else {\n      Yox.dom.off(node as HTMLElement, EVENT_CLICK, listener)\n    }\n  },\n},\n\nRouterView: ComponentOptions = {\n  template: templateRouterView,\n  beforeCreate(options) {\n\n    const context = options.context as YoxInterface,\n\n    // context 一定有 $route 属性\n    route = (context.$route as LinkedRoute).child as LinkedRoute\n\n    if (route) {\n\n      context.$routeView = this\n\n      const props = options.props = {}, components = options.components = {},\n\n      name = ROUTE_COMPONENT + (++guid)\n\n      props[ROUTE_COMPONENT] = name\n      components[name] = route.component\n\n    }\n\n  },\n  beforeDestroy() {\n    this.$context.$routeView = UNDEFINED\n  }\n}\n\n/**\n * 版本\n */\nexport const version = process.env.NODE_VERSION\n\n/**\n * 安装插件\n */\nexport function install(Y: typeof Yox): void {\n\n  Y.directive({\n    push: directive,\n    replace: directive,\n    go: directive,\n  })\n\n  Y.component('router-view', RouterView)\n\n  hookEvents = {}\n  hookEvents['beforeCreate' + NAMESPACE_HOOK] = function (event: CustomEventInterface, data?: Data) {\n    if (data) {\n      let options = data as ComponentOptions, { context } = options\n      // 当前组件是 <router-view> 中的动态组件\n      if (context && context.$options.beforeCreate === RouterView.beforeCreate) {\n        // 找到渲染 <router-view> 的父级组件，它是一定存在的\n        context = context.$context as YoxInterface\n\n        const router = context.$router as Router,\n\n        // context 一定有 $route 属性\n        route = (context.$route as LinkedRoute).child as LinkedRoute\n\n        if (route) {\n          options.extensions = {\n            $router: router,\n            $route: route,\n          }\n          if (router.location) {\n            options.props = filterProps(route, router.location, options)\n          }\n        }\n      }\n    }\n  }\n  hookEvents['afterMount' + NAMESPACE_HOOK] = function (event: CustomEventInterface) {\n    updateRoute(\n      event.target as YoxInterface,\n      COMPONENT_HOOK_AFTER_ENTER,\n      ROUTER_HOOK_AFTER_ENTER,\n      TRUE\n    )\n  }\n  hookEvents['afterUpdate' + NAMESPACE_HOOK] = function (event: CustomEventInterface) {\n    updateRoute(\n      event.target as YoxInterface,\n      COMPONENT_HOOK_AFTER_UPDATE,\n      ROUTER_HOOK_AFTER_UPDATE,\n      TRUE\n    )\n  }\n  hookEvents['afterDestroy' + NAMESPACE_HOOK] = function (event: CustomEventInterface) {\n    updateRoute(\n      event.target as YoxInterface,\n      COMPONENT_HOOK_AFTER_LEAVE,\n      ROUTER_HOOK_AFTER_LEAVE\n    )\n  }\n\n}\n\ndeclare module 'yox' {\n\n  interface ComponentOptions {\n    [COMPONENT_HOOK_BEFORE_ENTER]?: RouteBeforeHook\n    [COMPONENT_HOOK_AFTER_ENTER]?: RouteAfterHook\n    [COMPONENT_HOOK_BEFORE_UPDATE]?: RouteBeforeHook\n    [COMPONENT_HOOK_AFTER_UPDATE]?: RouteAfterHook\n    [COMPONENT_HOOK_BEFORE_LEAVE]?: RouteBeforeHook\n    [COMPONENT_HOOK_AFTER_LEAVE]?: RouteAfterHook\n  }\n\n  interface YoxInterface {\n    $routeView?: YoxInterface\n    $route?: LinkedRoute\n    $router?: Router\n  }\n\n}\n","import Yox from 'yox'\n\nimport {\n  SEPARATOR_QUERY,\n  SEPARATOR_PAIR,\n  FLAG_ARRAY,\n} from '../constant'\n\nimport * as valueUtil from './value'\n\n/**\n * 把 GET 参数解析成对象\n */\nexport function parse(query: string) {\n  let result: object | undefined\n  Yox.array.each(\n    query.split(SEPARATOR_QUERY),\n    function (term: string) {\n\n      let terms = term.split(SEPARATOR_PAIR),\n\n      key = Yox.string.trim(terms[0]),\n\n      value = terms[1]\n\n      if (key) {\n        if (!result) {\n          result = {}\n        }\n        value = valueUtil.parse(value)\n        if (Yox.string.endsWith(key, FLAG_ARRAY)) {\n          key = Yox.string.slice(key, 0, -FLAG_ARRAY.length)\n          Yox.array.push(\n            result[key] || (result[key] = []),\n            value\n          )\n        }\n        else {\n          result[key] = value\n        }\n      }\n\n    }\n  )\n  return result\n}\n\n/**\n * 把对象解析成 key1=value1&key2=value2\n */\nexport function stringify(query: object) {\n  const result: string[] = []\n  for (let key in query) {\n    const value = query[key]\n    if (Yox.is.array(value)) {\n      Yox.array.each(\n        value,\n        function (value: any) {\n          const str = valueUtil.stringify(value)\n          if (Yox.is.string(str)) {\n            result.push(\n              key + FLAG_ARRAY + SEPARATOR_PAIR + str\n            )\n          }\n        }\n      )\n    }\n    else {\n      const str = valueUtil.stringify(value)\n      if (Yox.is.string(str)) {\n        result.push(\n          key + SEPARATOR_PAIR + str\n        )\n      }\n    }\n  }\n  return result.join(SEPARATOR_QUERY)\n}\n"],"names":["const","WINDOW","window","LOCATION","location","HISTORY","history","Hooks","parse","value","let","result","Yox","is","numeric","string","decodeURIComponent","stringify","encodeURIComponent","number","boolean","toString","setLocation","to","from","this","clear","list","add","hook","ctx","push","fn","next","isGuard","callback","task","shift","call","isSupported","replaceState","url","handler","e","replace","dom","on","off","pushState","n","go","pathname","search","hash","protocol","host","href","index","indexOf","substr","length","hookEvents","guid","formatPath","path","parentPath","startsWith","endsWith","slice","stringifyUrl","params","query","test","terms","array","each","split","item","join","queryStr","key","str","valueUtil.stringify","queryUtil.stringify","filterProps","route","options","propTypes","props","routeParams","locationParams","object","copy","i","updateRoute","instance","componentHookName","routerHookName","upsert","$route","context","child","isLeafRoute","router","$router","pending","onComplete","Router","el","route404","default404","find","mode","historyMode.isSupported","historyMode","hashMode","parseLocation","current","setRoute","routes","name2Path","path2Route","hooks","routeOptions","parentRoute","newRoutes","pathStack","routeStack","addRoute","last","name","load","component","placeholderComponent","parent","children","pop","remove","target","setUrl","toUrl","start","stop","componentHook","routerHook","fire","onAbort","routeTarget","realpath","realpathTerms","matchRoute","loop","pathTerms","valueUtil.parse","routeCallback","lazyRoute","promise","then","term","trim","queryUtil.parse","diffRoute","oldRoute","startRoute","childRoute","oldTopRoute","patchRoute","forceUpdate","$routeView","destroy","extensions","extend","events","$vnode","linkedRoute","redirect","func","newRoute","oldLocation","enterRoute","template","directive","bind","node","vnode","$root","listener","data","_","getter","has","isComponent","unbind","RouterView","beforeCreate","components","beforeDestroy","$context","Y","event","$options"],"mappings":"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"}