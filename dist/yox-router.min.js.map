{"version":3,"file":"yox-router.min.js","sources":["../src/index.ts"],"sourcesContent":["import * as type from 'yox-type/src/type'\n\nimport API from 'yox-type/src/interface/API'\nimport Yox from 'yox-type/src/interface/Yox'\nimport YoxClass from 'yox-type/src/interface/YoxClass'\nimport Task from 'yox-type/src/interface/Task'\nimport YoxOptions from 'yox-type/src/options/Yox';\n\nlet Yox: YoxClass, store: Yox, domApi: API\n\nconst UNDEFINED = void 0,\n\n// hash 前缀，Google 的规范是 #! 开头，如 #!/path/sub?key=value\nPREFIX_HASH = '#!',\n\n// path 中的参数前缀，如 #!/user/:userId\nPREFIX_PARAM = ':',\n\n// path 分隔符\nSEPARATOR_PATH = '/',\n\n// query 分隔符\nSEPARATOR_QUERY = '&',\n\n// 键值对分隔符\nSEPARATOR_PAIR = '=',\n\n// 参数中的数组标识\nFLAG_ARRAY = '[]',\n\n// 默认路由\nROUTE_DEFAULT = '',\n\n// 404 路由\nROUTE_404 = '*',\n\n// 导航钩子 - 如果相继路由到的是同一个组件，那么会触发 refreshing 事件\nHOOK_REFRESHING = 'refreshing',\n\n// 导航钩子 - 路由进入之前\nHOOK_BEFORE_ENTER = 'beforeEnter',\n\n// 导航钩子 - 路由进入之后\nHOOK_AFTER_ENTER = 'afterEnter',\n\n// 导航钩子 - 路由离开之前\nHOOK_BEFORE_LEAVE = 'beforeLeave',\n\n// 导航钩子 - 路由离开之后\nHOOK_AFTER_LEAVE = 'afterLeave'\n\ntype PathTarget = string\n\ninterface RouteTarget {\n  name: string\n  params?: type.data\n  query?: type.data\n}\n\ninterface ComponentTarget {\n  component: string\n  props?: type.data\n}\n\ntype Target = PathTarget | RouteTarget | ComponentTarget\n\ntype next = (value?: false | Target) => void\n\ntype success = () => void\n\ntype failure = (value: false | Target) => void\n\ntype hook = (to: Route, from: Route | void, next: next) => void\n\ninterface RouteOptions {\n  component: string\n  name?: string\n  [HOOK_REFRESHING]?: hook\n  [HOOK_BEFORE_ENTER]?: hook\n  [HOOK_AFTER_ENTER]?: hook\n  [HOOK_BEFORE_LEAVE]?: hook\n  [HOOK_AFTER_LEAVE]?: hook\n}\n\ninterface Route {\n  component: string\n  props?: type.data\n  path?: string\n  params?: type.data\n  query?: type.data\n}\n\ninterface Component {\n  name: string\n  root?: Yox\n  options?: YoxOptions\n}\n\ninterface Hash {\n  realpath: string\n  path?: string\n  params?: type.data\n  query?: type.data\n}\n\n/**\n * 把字符串 value 解析成最合适的类型\n */\nfunction parseValue(value: string) {\n  let result: any\n  if (Yox.is.numeric(value)) {\n    result = +value\n  }\n  else if (Yox.is.string(value)) {\n    if (value === 'true') {\n      result = true\n    }\n    else if (value === 'false') {\n      result = false\n    }\n    else if (value === 'null') {\n      result = null\n    }\n    else if (value === 'undefined') {\n      result = UNDEFINED\n    }\n    else {\n      result = decodeURIComponent(value)\n    }\n  }\n  return result\n}\n\n/**\n * 把 key value 序列化成合适的 key=value 格式\n */\nfunction stringifyPair(key: string, value: any) {\n  let result = [key]\n  if (Yox.is.string(value)) {\n    result.push(\n      encodeURIComponent(value)\n    )\n  }\n  else if (Yox.is.number(value) || Yox.is.boolean(value)) {\n    result.push(\n      value.toString()\n    )\n  }\n  else if (value === null) {\n    result.push(\n      'null'\n    )\n  }\n  else if (value === UNDEFINED) {\n    result.push(\n      'undefined'\n    )\n  }\n  return result.join(SEPARATOR_PAIR)\n}\n\n/**\n * 把 GET 参数解析成对象\n */\nfunction parseQuery(query: string) {\n  let result: Object | undefined\n  Yox.array.each(\n    query.split(SEPARATOR_QUERY),\n    function (term) {\n\n      let terms = term.split(SEPARATOR_PAIR),\n\n      key = Yox.string.trim(terms[0]),\n\n      value = terms[1]\n\n      if (key) {\n        if (!result) {\n          result = {}\n        }\n        value = parseValue(value)\n        if (Yox.string.endsWith(key, FLAG_ARRAY)) {\n          key = Yox.string.slice(key, 0, -FLAG_ARRAY.length)\n          Yox.array.push(\n            result[key] || (result[key] = []),\n            value\n          )\n        }\n        else {\n          result[key] = value\n        }\n      }\n\n    }\n  )\n  return result\n}\n\n/**\n * 把对象解析成 key1=value1&key2=value2\n */\nfunction stringifyQuery(query: Object) {\n  const result: string[] = []\n  Yox.object.each(\n    query,\n    function (value, key) {\n      if (Yox.is.array(value)) {\n        Yox.array.each(\n          value,\n          function (value) {\n            result.push(\n              stringifyPair(key + FLAG_ARRAY, value)\n            )\n          }\n        )\n      }\n      else {\n        result.push(\n          stringifyPair(key, value)\n        )\n      }\n    }\n  )\n  return result.join(SEPARATOR_QUERY)\n}\n\n/**\n * 解析 path 中的参数\n */\nfunction parseParams(realpath: string, path: string) {\n\n  let result: Object | undefined,\n\n  realpathTerms = realpath.split(SEPARATOR_PATH),\n\n  pathTerms = path.split(SEPARATOR_PATH)\n\n  if (realpathTerms.length === pathTerms.length) {\n    Yox.array.each(\n      pathTerms,\n      function (item, index) {\n        if (Yox.string.startsWith(item, PREFIX_PARAM)) {\n          if (!result) {\n            result = {}\n          }\n          result[item.substr(PREFIX_PARAM.length)] = parseValue(realpathTerms[index])\n        }\n      }\n    )\n  }\n\n  return result\n\n}\n\n/**\n * 通过 realpath 获取配置的 path\n */\nfunction getPathByRealpath(path2Route: Object, realpath: string) {\n\n  let result: string | undefined,\n\n  realpathTerms = realpath.split(SEPARATOR_PATH),\n\n  length = realpathTerms.length\n\n  Yox.object.each(\n    path2Route,\n    function (_, path) {\n      const pathTerms = path.split(SEPARATOR_PATH)\n      if (length === pathTerms.length) {\n        for (let i = 0; i < length; i++) {\n          // 非参数段不相同\n          if (!Yox.string.startsWith(pathTerms[i], PREFIX_PARAM)\n            && pathTerms[i] !== realpathTerms[i]\n          ) {\n            return\n          }\n        }\n        result = path\n        return false\n      }\n    }\n  )\n\n  return result\n\n}\n\n/**\n * 完整解析 hash 数据\n */\nfunction parseHash(path2Route: Object, hash: string) {\n\n  let realpath: string, search: string | void, index = hash.indexOf('?')\n\n  if (index >= 0) {\n    realpath = hash.substring(0, index)\n    search = hash.substring(index + 1)\n  }\n  else {\n    realpath = hash\n  }\n\n  let result: Hash = { realpath }\n\n  let path = getPathByRealpath(path2Route, realpath)\n  if (path) {\n    result.path = path\n    const params = parseParams(realpath, path)\n    if (params) {\n      result.params = params\n    }\n    if (search) {\n      const query = parseQuery(search)\n      if (query) {\n        result.query = query\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * 把结构化数据序列化成 hash\n */\nfunction stringifyHash(path: string, params: Object | void, query: Object | void) {\n\n  let terms: string[] = [], realpath: string, search = ''\n\n  Yox.array.each(\n    path.split(SEPARATOR_PATH),\n    function (item) {\n      terms.push(\n        Yox.string.startsWith(item, PREFIX_PARAM)\n          ? params[item.substr(PREFIX_PARAM.length)]\n          : item\n      )\n    }\n  )\n\n  realpath = terms.join(SEPARATOR_PATH)\n\n  if (query) {\n    const queryStr = stringifyQuery(query)\n    if (queryStr) {\n      search = '?' + queryStr\n    }\n  }\n\n  return PREFIX_HASH + realpath + search\n\n}\n\n// 钩子函数的调用链\nclass Chain {\n\n  name: string\n\n  list: Task[]\n\n  constructor(name: string) {\n    this.name = name\n    this.list = []\n  }\n\n  append(target: Object | void, ctx: any) {\n    const { name, list } = this\n    if (target && Yox.is.func(target[name])) {\n      list.push({\n        fn: target[name] as Function,\n        ctx,\n      })\n    }\n    return this\n  }\n\n  run(to: Route, from: Route | void, success: success | void, failure: failure | void) {\n\n    const { list } = this,\n\n    next: next = function (value?: false | Target) {\n      if (value == null) {\n        const task = list.shift()\n        if (task) {\n          task.fn.call(task.ctx, to, from, next)\n        }\n        else if (success) {\n          success()\n        }\n      }\n      else if (failure) {\n        failure(value)\n      }\n    }\n\n    next()\n\n  }\n\n}\n\nexport class Router {\n\n  el?: Element\n\n  name2Path: Record<string, string>\n\n  path2Route: Record<string, RouteOptions>\n\n  onHashChange: Function\n\n  currentRoute?: Route\n\n  currentComponent?: Component\n\n  [HOOK_REFRESHING]?: hook\n\n  [HOOK_BEFORE_ENTER]?: hook\n\n  [HOOK_AFTER_ENTER]?: hook\n\n  [HOOK_BEFORE_LEAVE]?: hook\n\n  [HOOK_AFTER_LEAVE]?: hook\n\n  constructor(routes: Record<string, RouteOptions>) {\n\n    const instance = this\n\n    /**\n     * 路由表 name -> path\n     */\n    instance.name2Path = {}\n\n    /**\n     * 路由表 path -> route\n     */\n    instance.path2Route = {}\n\n    /**\n     * hashchange 事件处理函数\n     * 此函数必须写在实例上，不能写在类上\n     * 否则一旦解绑，所有实例都解绑了\n     */\n    instance.onHashChange = function () {\n\n      let hashStr = location.hash\n\n      // 如果不以 PREFIX_HASH 开头，表示不合法\n      hashStr = Yox.string.startsWith(hashStr, PREFIX_HASH)\n        ? hashStr.substr(PREFIX_HASH.length)\n        : ''\n\n      const hash = parseHash(instance.path2Route, hashStr),\n\n      path = hash.path || (hashStr ? ROUTE_404 : ROUTE_DEFAULT),\n\n      options = instance.path2Route[path]\n\n      instance.setRoute(\n        {\n          component: options.component,\n          path,\n          params: hash.params,\n          query: hash.query,\n        },\n        options\n      )\n\n    }\n\n    if (process.env.NODE_ENV === 'dev') {\n      if (!Yox.object.has(routes, ROUTE_DEFAULT)) {\n        Yox.logger.error(`Route for default[\"${ROUTE_DEFAULT}\"] is required.`)\n        return\n      }\n      if (!Yox.object.has(routes, ROUTE_404)) {\n        Yox.logger.error(`Route for 404[\"${ROUTE_404}\"] is required.`)\n        return\n      }\n    }\n\n    Yox.object.each(\n      routes,\n      function (route: RouteOptions, path: string) {\n        if (route.name) {\n          instance.name2Path[route.name] = path\n        }\n        instance.path2Route[path] = route\n      }\n    )\n\n  }\n\n  /**\n   * 真正执行路由切换操作的函数\n   *\n   * data 有 2 种格式：\n   *\n   * 1. 会修改 url\n   *\n   * 如果只是简单的 path，直接传字符串\n   *\n   * go('/index')\n   *\n   * 如果需要带参数，切记路由表要配置 name\n   *\n   * go({\n   *   name: 'index',\n   *   params: { },\n   *   query: { }\n   * })\n   *\n   * 如果没有任何参数，可以只传 path\n   *\n   * go('/index')\n   *\n   * 2. 不会改变 url\n   *\n   * go({\n   *   component: 'index',\n   *   props: { }\n   * })\n   *\n   */\n  go(target: Target) {\n    if (Yox.is.string(target)) {\n      location.hash = stringifyHash(target as PathTarget)\n    }\n    else if (Yox.is.object(target)) {\n      if (Yox.object.has(target, 'component')) {\n\n        const { component, props } = target as ComponentTarget\n\n        this.setRoute({\n          component,\n          props,\n        })\n\n      }\n      else if (Yox.object.has(target, 'name')) {\n\n        const { name, params, query } = target as RouteTarget, path = this.name2Path[name]\n\n        if (process.env.NODE_ENV === 'dev') {\n          if (!Yox.is.string(path)) {\n            Yox.logger.error(`Name[${name}] of the route is not found.`)\n            return\n          }\n        }\n\n        location.hash = stringifyHash(path, params, query)\n\n      }\n    }\n  }\n\n  /**\n   * 切换路由\n   */\n  setRoute(route: Route, options?: RouteOptions) {\n\n    let instance = this,\n\n    { currentRoute } = instance,\n\n    { params, query, component, props } = route,\n\n    currentComponent = instance.currentComponent || (instance.currentComponent = { name: component }),\n\n    failure: failure = function (value: false | Target) {\n      if (value === false) {\n        // 流程到此为止，恢复到当前路由\n        if (currentRoute && currentRoute.path) {\n          location.hash = stringifyHash(\n            currentRoute.path as string,\n            currentRoute.params,\n            currentRoute.query\n          )\n        }\n      }\n      else {\n        // 跳转到别的路由\n        instance.go(value)\n      }\n    },\n\n    callHook = function (name: string, success: success | void, failure: failure | void) {\n      new Chain(name)\n      // 先调用组件的钩子\n      .append(currentComponent.options, currentComponent.root)\n      // 再调用路由配置的钩子\n      .append(options, options)\n      // 最后调用路由实例的钩子\n      .append(instance, instance)\n      .run(route, currentRoute, success, failure)\n    },\n\n    createComponent = function (options: YoxOptions) {\n\n      currentComponent.options = options\n\n      callHook(\n        HOOK_BEFORE_ENTER,\n        function () {\n\n          if (params || query) {\n            props = {}\n            if (params) {\n              Yox.object.extend(props, params)\n            }\n            if (query) {\n              Yox.object.extend(props, query)\n            }\n          }\n\n          currentComponent.root = new Yox(\n            Yox.object.extend(\n              {\n                el: instance.el,\n                props,\n                extensions: {\n                  $router: instance,\n                }\n              },\n              options\n            )\n          )\n\n          instance.currentRoute = route\n\n          callHook(HOOK_AFTER_ENTER)\n\n        },\n        failure\n      )\n    },\n\n    changeComponent = function (options: YoxOptions) {\n      callHook(\n        HOOK_BEFORE_LEAVE,\n        function () {\n          if (currentComponent.root) {\n            currentComponent.root.destroy()\n            currentComponent.root = UNDEFINED\n          }\n          callHook(HOOK_AFTER_LEAVE)\n          createComponent(options)\n        },\n        failure\n      )\n    }\n\n    if (currentComponent.name !== component) {\n      currentComponent.name = component\n    }\n\n    store.component(\n      component,\n      function (options: YoxOptions) {\n        // 当连续调用此方法，且可能出现异步组件时\n        // 执行到这 name 不一定会等于 currentComponent.name\n        // 因此需要强制保证一下\n        if (component !== currentComponent.name) {\n          return\n        }\n\n        if (currentComponent.root) {\n          // 当前根组件还活着，并且还要切到当前根组件，表示刷新一下\n          if (currentComponent.options === options) {\n            callHook(\n              HOOK_REFRESHING,\n              function () {\n                // 如果 refreshing 钩子调用了 next()\n                // 表示要销毁重建当前根组件\n                changeComponent(options)\n              },\n              failure\n            )\n          }\n          // 切换到其他组件\n          else {\n            changeComponent(options)\n          }\n        }\n        // 第一次创建组件\n        else {\n          createComponent(options)\n        }\n\n      }\n    )\n\n  }\n\n  /**\n   * 启动路由\n   */\n  start(el: string | Element) {\n    if (Yox.is.string(el)) {\n      const element = domApi.find(el as string)\n      if (element) {\n        this.el = element\n      }\n    }\n    else {\n      this.el = el as Element\n    }\n    domApi.on(window, 'hashchange', this.onHashChange as type.listener)\n    this.onHashChange()\n  }\n\n  /**\n   * 停止路由\n   */\n  stop() {\n    this.el = UNDEFINED\n    domApi.off(window, 'hashchange', this.onHashChange as type.listener)\n  }\n\n}\n\n/**\n * 版本\n */\nexport const version = process.env.NODE_VERSION\n\n/**\n * 注册全局组件，路由实例可共享\n */\nexport function register(\n  name: string | Record<string, type.component>,\n  component?: type.component\n): void {\n  store.component(name, component)\n}\n\n/**\n * 安装插件\n */\nexport function install(Class: YoxClass): void {\n  Yox = Class\n  store = new Class()\n  domApi = Class.dom as API\n}\n"],"names":["Yox","store","domApi","UNDEFINED","PREFIX_HASH","PREFIX_PARAM","SEPARATOR_PATH","SEPARATOR_QUERY","SEPARATOR_PAIR","FLAG_ARRAY","ROUTE_DEFAULT","ROUTE_404","parseValue","value","result","is","numeric","string","decodeURIComponent","stringifyPair","key","push","encodeURIComponent","number","boolean","toString","join","parseHash","path2Route","hash","realpath","search","index","indexOf","substring","path","realpathTerms","split","length","object","each","_","pathTerms","i","startsWith","getPathByRealpath","params","array","item","substr","parseParams","query","term","terms","trim","endsWith","slice","parseQuery","stringifyHash","queryStr","stringifyQuery","name","this","list","Chain","target","ctx","func","fn","to","from","success","failure","next","task","shift","call","routes","instance","name2Path","onHashChange","hashStr","location","options","setRoute","component","route","Router","has","_a","props","_b","currentRoute","currentComponent","go","callHook","append","root","run","createComponent","extend","el","extensions","$router","changeComponent","destroy","element","find","on","window","off","Class","dom"],"mappings":"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"}