{"version":3,"file":"yox-router.min.js","sources":["../../yox-common/src/util/env.ts","../src/Hooks.ts","../src/constant.ts","../src/value.ts","../src/location.ts","../src/query.ts","../src/index.ts"],"sourcesContent":["/**\n * 为了压缩，定义的常量\n */\nexport const TRUE = true\nexport const FALSE = false\nexport const NULL = null\nexport const UNDEFINED = void 0\n\nexport const RAW_TRUE = 'true'\nexport const RAW_FALSE = 'false'\nexport const RAW_NULL = 'null'\nexport const RAW_UNDEFINED = 'undefined'\n\nexport const RAW_KEY = 'key'\nexport const RAW_REF = 'ref'\nexport const RAW_SLOT = 'slot'\nexport const RAW_NAME = 'name'\n\nexport const RAW_FILTER = 'filter'\nexport const RAW_PARTIAL = 'partial'\nexport const RAW_COMPONENT = 'component'\nexport const RAW_DIRECTIVE = 'directive'\nexport const RAW_TRANSITION = 'transition'\n\nexport const RAW_THIS = 'this'\nexport const RAW_VALUE = 'value'\nexport const RAW_LENGTH = 'length'\nexport const RAW_FUNCTION = 'function'\nexport const RAW_TEMPLATE = 'template'\nexport const RAW_WILDCARD = '*'\n\nexport const KEYPATH_PARENT = '..'\nexport const KEYPATH_CURRENT = RAW_THIS\n\nexport const RAW_MINUS_ONE = -1\n\n/**\n * Single instance for window in browser\n */\nexport const WINDOW = typeof window !== RAW_UNDEFINED ? window : UNDEFINED\n\n/**\n * Single instance for document in browser\n */\nexport const DOCUMENT = typeof document !== RAW_UNDEFINED ? document : UNDEFINED\n\n/**\n * tap 事件\n *\n * 非常有用的抽象事件，比如 pc 端是 click 事件，移动端是 touchend 事件\n *\n * 这样只需 on-tap=\"handler\" 就可以完美兼容各端\n *\n * 框架未实现此事件，通过 Yox.dom.specialEvents 提供给外部扩展\n *\n */\nexport const EVENT_TAP = 'tap'\n\n/**\n * 点击事件\n */\nexport const EVENT_CLICK = 'click'\n\n/**\n * 输入事件\n */\nexport const EVENT_INPUT = 'input'\n\n/**\n * 变化事件\n */\nexport const EVENT_CHANGE = 'change'\n\n/**\n * 唯一内置的特殊事件：model\n */\nexport const EVENT_MODEL = 'model'\n\n/**\n * Single instance for noop function\n */\nexport const EMPTY_FUNCTION = function () {\n  /** yox */\n}\n\n/**\n * 空对象，很多地方会用到，比如 `a || EMPTY_OBJECT` 确保是个对象\n */\nexport const EMPTY_OBJECT = Object.freeze({})\n\n/**\n * 空数组\n */\nexport const EMPTY_ARRAY = Object.freeze([])\n\n/**\n * 空字符串\n */\nexport const EMPTY_STRING = ''","import Task from '../../yox-type/src/interface/Task'\n\nimport * as type from './type'\n\nexport default class Hooks {\n\n  list: Task[]\n\n  to: type.Location\n\n  from: type.Location | void\n\n  setLocation(to: type.Location, from: type.Location | void) {\n    this.to = to\n    this.from = from\n    return this\n  }\n\n  clear() {\n    this.list = []\n    return this\n  }\n\n  add(hook: Function | void, ctx: any) {\n    const { list } = this\n    if (hook) {\n      list.push({\n        fn: hook,\n        ctx,\n      })\n    }\n    return this\n  }\n\n  next(next: type.Next, isGuard?: boolean, callback?: type.Callback) {\n    const task = this.list.shift()\n    if (task) {\n      if (isGuard) {\n        task.fn.call(task.ctx, this.to, this.from, next)\n      }\n      else {\n        task.fn.call(task.ctx, this.to, this.from)\n        next()\n      }\n    }\n    else if (callback) {\n      callback()\n    }\n  }\n\n}","// hash 前缀，Google 的规范是 #! 开头，如 #!/path/sub?key=value\nexport const PREFIX_HASH = '#!'\n\n// path 中的参数前缀，如 #!/user/:userId\nexport const PREFIX_PARAM = ':'\n\n// path 分隔符\nexport const SEPARATOR_PATH = '/'\n\n// path 和 search 的分隔符\nexport const SEPARATOR_SEARCH = '?'\n\n// query 分隔符\nexport const SEPARATOR_QUERY = '&'\n\n// 键值对分隔符\nexport const SEPARATOR_PAIR = '='\n\n// 参数中的数组标识\nexport const FLAG_ARRAY = '[]'\n\n// 导航钩子 - 路由进入之前\nexport const HOOK_BEFORE_ENTER = 'beforeEnter'\nexport const HOOK_BEFORE_ROUTE_ENTER = 'beforeRouteEnter'\n\n// 导航钩子 - 路由进入之后\nexport const HOOK_AFTER_ENTER = 'afterEnter'\nexport const HOOK_AFTER_ROUTE_ENTER = 'afterRouteEnter'\n\n// 导航钩子 - 路由更新之前\nexport const HOOK_BEFORE_UPDATE = 'beforeUpdate'\nexport const HOOK_BEFORE_ROUTE_UPDATE = 'beforeRouteUpdate'\n\n// 导航钩子 - 路由更新之后\nexport const HOOK_AFTER_UPDATE = 'afterUpdate'\nexport const HOOK_AFTER_ROUTE_UPDATE = 'afterRouteUpdate'\n\n// 导航钩子 - 路由离开之前\nexport const HOOK_BEFORE_LEAVE = 'beforeLeave'\nexport const HOOK_BEFORE_ROUTE_LEAVE = 'beforeRouteLeave'\n\n// 导航钩子 - 路由离开之后\nexport const HOOK_AFTER_LEAVE = 'afterLeave'\nexport const HOOK_AFTER_ROUTE_LEAVE = 'afterRouteLeave'","import * as env from '../../yox-common/src/util/env'\nimport YoxClass from '../../yox-type/src/interface/YoxClass'\n\n/**\n * 把字符串 value 解析成最合适的类型\n */\nexport function parse(Yox: YoxClass, value: string) {\n  let result: any\n  if (Yox.is.numeric(value)) {\n    result = +value\n  }\n  else if (Yox.is.string(value)) {\n    if (value === env.RAW_TRUE) {\n      result = env.TRUE\n    }\n    else if (value === env.RAW_FALSE) {\n      result = env.FALSE\n    }\n    else if (value === env.RAW_NULL) {\n      result = env.NULL\n    }\n    else if (value === env.RAW_UNDEFINED) {\n      result = env.UNDEFINED\n    }\n    else {\n      result = decodeURIComponent(value)\n    }\n  }\n  return result\n}\n\nexport function stringify(Yox: YoxClass, value: any): string {\n  if (Yox.is.string(value)) {\n    return encodeURIComponent(value)\n  }\n  else if (Yox.is.number(value) || Yox.is.boolean(value)) {\n    return value.toString()\n  }\n  else if (value === env.NULL) {\n    return env.RAW_NULL\n  }\n  return env.RAW_UNDEFINED\n}","import YoxClass from '../../yox-type/src/interface/YoxClass'\n\nimport * as type from './type'\nimport * as constant from './constant'\nimport * as valueUtil from './value'\nimport * as queryUtil from './query'\n\n/**\n * 解析 path 中的参数\n */\nfunction parseParams(Yox: YoxClass, path: string, realpath: string) {\n\n  let result: Object | undefined,\n\n  realpathTerms = realpath.split(constant.SEPARATOR_PATH),\n\n  pathTerms = path.split(constant.SEPARATOR_PATH)\n\n  if (realpathTerms.length === pathTerms.length) {\n    Yox.array.each(\n      pathTerms,\n      function (item, index) {\n        if (Yox.string.startsWith(item, constant.PREFIX_PARAM)) {\n          if (!result) {\n            result = {}\n          }\n          result[item.substr(constant.PREFIX_PARAM.length)] = valueUtil.parse(Yox, realpathTerms[index])\n        }\n      }\n    )\n  }\n\n  return result\n\n}\n\n/**\n * 通过 realpath 获取配置的路由\n */\nfunction getRouteByRealpath(Yox: YoxClass, routes: type.LinkedRoute[], realpath: string) {\n\n  let realpathTerms = realpath.split(constant.SEPARATOR_PATH),\n\n  length = realpathTerms.length,\n\n  i = 0,\n\n  route: type.LinkedRoute | void\n\n  loop: while (route = routes[i++]) {\n    if (route.params) {\n      const pathTerms = route.path.split(constant.SEPARATOR_PATH)\n      if (length === pathTerms.length) {\n        for (let l = 0; l < length; l++) {\n          // 非参数段不相同\n          if (!Yox.string.startsWith(pathTerms[l], constant.PREFIX_PARAM)\n            && pathTerms[l] !== realpathTerms[l]\n          ) {\n            continue loop\n          }\n        }\n        return route\n      }\n    }\n    else if (route.path === realpath) {\n      return route\n    }\n  }\n\n}\n\nexport function parse(Yox: YoxClass, routes: type.LinkedRoute[], hash: string) {\n\n  let realpath: string, search: string | void, index = hash.indexOf(constant.SEPARATOR_SEARCH)\n\n  if (index >= 0) {\n    realpath = hash.slice(0, index)\n    search = hash.slice(index + 1)\n  }\n  else {\n    realpath = hash\n  }\n\n  const route = getRouteByRealpath(Yox, routes, realpath)\n\n  if (route) {\n    const result: type.Location = {\n      hash,\n      path: route.path\n    }\n    if (route.params) {\n      const params = parseParams(Yox, route.path, realpath)\n      if (params) {\n        result.params = params\n      }\n    }\n    if (search) {\n      const query = queryUtil.parse(Yox, search)\n      if (query) {\n        result.query = query\n      }\n    }\n    return result\n  }\n\n}\n\n/**\n * 把结构化数据序列化成 hash\n */\nexport function stringify(Yox: YoxClass, location: type.Location) {\n\n  const { path, params, query } = location, terms: string[] = []\n\n  Yox.array.each(\n    path.split(constant.SEPARATOR_PATH),\n    function (item) {\n      terms.push(\n        Yox.string.startsWith(item, constant.PREFIX_PARAM) && params\n          ? params[item.substr(constant.PREFIX_PARAM.length)]\n          : item\n      )\n    }\n  )\n\n  let realpath = terms.join(constant.SEPARATOR_PATH)\n\n  if (query) {\n    const queryStr = queryUtil.stringify(Yox, query)\n    if (queryStr) {\n      realpath += constant.SEPARATOR_SEARCH + queryStr\n    }\n  }\n\n  return realpath\n\n}","\nimport YoxClass from '../../yox-type/src/interface/YoxClass'\n\nimport * as constant from './constant'\nimport * as valueUtil from './value'\n\n/**\n * 把 GET 参数解析成对象\n */\nexport function parse(Yox: YoxClass, query: string) {\n  let result: Object | undefined\n  Yox.array.each(\n    query.split(constant.SEPARATOR_QUERY),\n    function (term) {\n\n      let terms = term.split(constant.SEPARATOR_PAIR),\n\n      key = Yox.string.trim(terms[0]),\n\n      value = terms[1]\n\n      if (key) {\n        if (!result) {\n          result = {}\n        }\n        value = valueUtil.parse(Yox, value)\n        if (Yox.string.endsWith(key, constant.FLAG_ARRAY)) {\n          key = Yox.string.slice(key, 0, -constant.FLAG_ARRAY.length)\n          Yox.array.push(\n            result[key] || (result[key] = []),\n            value\n          )\n        }\n        else {\n          result[key] = value\n        }\n      }\n\n    }\n  )\n  return result\n}\n\n/**\n * 把对象解析成 key1=value1&key2=value2\n */\nexport function stringify(Yox: YoxClass, query: Object) {\n  const result: string[] = []\n  for (let key in query) {\n    const value = query[key]\n    if (Yox.is.array(value)) {\n      Yox.array.each(\n        value,\n        function (value) {\n          result.push(\n            key + constant.FLAG_ARRAY + constant.SEPARATOR_PAIR + valueUtil.stringify(Yox, value)\n          )\n        }\n      )\n    }\n    else {\n      result.push(\n        key + constant.SEPARATOR_PAIR + valueUtil.stringify(Yox, value)\n      )\n    }\n  }\n  return result.join(constant.SEPARATOR_QUERY)\n}\n","import * as type from '../../yox-type/src/type'\nimport * as routerType from './type'\n\nimport * as env from '../../yox-common/src/util/env'\n\nimport API from '../../yox-type/src/interface/API'\nimport Yox from '../../yox-type/src/interface/Yox'\nimport YoxClass from '../../yox-type/src/interface/YoxClass'\n\nimport YoxOptions from '../../yox-type/src/options/Yox'\nimport VNode from '../../yox-type/src/vnode/VNode'\nimport Directive from '../../yox-type/src/vnode/Directive'\nimport CustomEvent from '../../yox-type/src/event/CustomEvent'\n\nimport Hooks from './Hooks'\nimport * as constant from './constant'\nimport * as locationUtil from './location'\n\nlet Yox: YoxClass, domApi: API, guid = 0\n\nconst WINDOW = window,\n\nLOCATION = WINDOW.location,\n\nROUTER = '$router',\n\nROUTE = '$route',\n\nROUTE_VIEW = '$routeView',\n\nROUTE_COMPONENT = 'RouteComponent',\n\nEVENT_CLICK = 'click',\n\nEVENT_HASH_CHANGE = 'hashchange'\n\n/**\n * 格式化路径，确保它以 / 开头，不以 / 结尾\n */\nfunction formatPath(path: string, parentPath: string | void) {\n\n  if (!Yox.string.startsWith(path, constant.SEPARATOR_PATH)) {\n    // 确保 parentPath 以 / 结尾\n    if (parentPath) {\n      if (!Yox.string.endsWith(parentPath, constant.SEPARATOR_PATH)) {\n        parentPath += constant.SEPARATOR_PATH\n      }\n    }\n    else {\n      parentPath = constant.SEPARATOR_PATH\n    }\n    path = parentPath + path\n  }\n\n  // 如果 path 以 / 结尾，删掉它\n  if (path !== constant.SEPARATOR_PATH\n    && Yox.string.endsWith(path, constant.SEPARATOR_PATH)\n  ) {\n    path = Yox.string.slice(path, 0, -constant.SEPARATOR_PATH.length)\n  }\n\n  return path\n}\n\nfunction toLocation(target: routerType.Target, name2Path: type.data): routerType.Location {\n\n  const location: routerType.Location = {\n    hash: env.EMPTY_STRING,\n    path: env.EMPTY_STRING\n  }\n\n  if (Yox.is.string(target)) {\n    location.path = formatPath(target as string)\n  }\n  else {\n    const route = target as routerType.RouteTarget, name = route.name\n    if (name) {\n      location.path = name2Path[name]\n      if (process.env.NODE_ENV === 'development') {\n        if (!Yox.is.string(location.path)) {\n          Yox.logger.error(`The route of name[${name}] is not found.`)\n        }\n      }\n    }\n    else {\n      location.path = formatPath(route.path as string)\n    }\n    if (route.params) {\n      location.params = route.params\n    }\n    if (route.query) {\n      location.query = route.query\n    }\n  }\n\n  return location\n\n}\n\n/**\n * 按照 propTypes 定义的外部数据格式过滤路由参数，这样有两个好处：\n *\n * 1. 避免传入不符预期的数据\n * 2. 避免覆盖 data 定义的数据\n */\nfunction filterProps(route: routerType.LinkedRoute, location: routerType.Location, options: YoxOptions) {\n  const result: type.data = {}, propTypes = options.propTypes\n  if (propTypes) {\n\n    let props = location.query,\n\n    routeParams = route.params,\n\n    locationParams = location.params\n\n    // 从 location.params 挑出 route.params 定义过的参数\n    if (routeParams && locationParams) {\n      props = props ? Yox.object.copy(props) : {}\n      for (let i = 0, key: string; key = routeParams[i]; i++) {\n        (props as type.data)[key] = locationParams[key]\n      }\n    }\n\n    if (props) {\n      for (let key in propTypes) {\n        result[key] = Yox.checkProp(key, props[key], propTypes[key])\n      }\n    }\n\n  }\n  return result\n}\n\n/**\n * 是否是叶子节点\n * 如果把叶子节点放在 if 中，会出现即使不是定义时的叶子节点，却是运行时的叶子节点\n */\nfunction isLeafRoute(route: routerType.LinkedRoute) {\n  const child = route.child\n  return !child || !child.context\n}\n\nfunction updateRoute(instance: Yox, componentHook: string | void, hook: string | undefined, upsert?: boolean) {\n  const route = instance[ROUTE] as routerType.LinkedRoute\n  if (route) {\n    route.context = upsert ? instance : env.UNDEFINED\n    if (isLeafRoute(route)) {\n      const router = instance[ROUTER] as Router\n      if (componentHook && hook) {\n        router.hook(route, componentHook, hook)\n      }\n      if (upsert && router.loading) {\n        router.loading.onComplete()\n        router.loading = env.UNDEFINED\n      }\n    }\n  }\n}\n\nexport class Router {\n\n  el: Element\n\n  routes: routerType.LinkedRoute[]\n\n  route404: routerType.LinkedRoute\n\n  name2Path: Record<string, string>\n\n  path2Route: Record<string, routerType.LinkedRoute>\n\n  history: routerType.Location[]\n\n  cursor: number\n\n  loading: routerType.Loading | void\n\n  hooks: Hooks\n\n  // 路由或参数发生了变化会触发此函数\n  onHashChange: Function\n\n  // 当前渲染的路由\n  route?: routerType.LinkedRoute\n\n  // 当前地址栏的路径和参数\n  location?: routerType.Location\n\n  [constant.HOOK_BEFORE_LEAVE]?: routerType.BeforeHook\n\n  [constant.HOOK_BEFORE_ENTER]?: routerType.BeforeHook\n\n  [constant.HOOK_AFTER_ENTER]?: routerType.AfterHook\n\n  [constant.HOOK_AFTER_LEAVE]?: routerType.AfterHook\n\n  constructor(options: routerType.RouterOptions) {\n\n    const instance = this, { el, route404 } = options\n\n    instance.el = Yox.is.string(el)\n      ? domApi.find(el as string) as Element\n      : el as Element\n\n    if (process.env.NODE_ENV === 'development') {\n      if (!instance.el) {\n        Yox.logger.error(`router.el is not an element.`)\n        return\n      }\n      if (!route404) {\n        Yox.logger.error(`Route for 404 is required.`)\n        return\n      }\n    }\n\n    /**\n     * hashchange 事件处理函数\n     * 此函数必须写在实例上，不能写在类上\n     * 否则一旦解绑，所有实例都解绑了\n     */\n    instance.onHashChange = function () {\n\n      let hashStr = LOCATION.hash, { loading, routes, route404 } = instance\n\n      // 如果不以 PREFIX_HASH 开头，表示不合法\n      hashStr = hashStr !== constant.PREFIX_HASH\n        && Yox.string.startsWith(hashStr, constant.PREFIX_HASH)\n        ? hashStr.substr(constant.PREFIX_HASH.length)\n        : constant.SEPARATOR_PATH\n\n      if (loading) {\n        // 通过 push 或 go 触发\n        if (loading.location.hash === hashStr) {\n          instance.setRoute(loading.location)\n          return\n        }\n        instance.loading = env.UNDEFINED\n      }\n\n      // 直接修改地址栏触发\n      const location = locationUtil.parse(Yox, routes, hashStr)\n      if (location) {\n        instance.pushHistory(location)\n        instance.setRoute(location)\n        return\n      }\n\n      instance.push(route404)\n\n    }\n\n    instance.routes = []\n    instance.name2Path = {}\n    instance.path2Route = {}\n\n    instance.history = []\n    instance.cursor = -1\n\n    instance.hooks = new Hooks()\n\n    instance.add(options.routes)\n    instance.add([route404])\n\n    instance.route404 = Yox.array.last(instance.routes) as routerType.LinkedRoute\n\n  }\n\n  /**\n   * 添加新的路由\n   */\n  add(routes: routerType.RouteOptions[]) {\n\n    let instance = this,\n\n    pathStack: string[] = [],\n\n    routeStack: routerType.LinkedRoute[] = [],\n\n    callback = function (routeOptions: routerType.RouteOptions) {\n\n      let { name, component, children } = routeOptions,\n\n      parentPath = Yox.array.last(pathStack),\n\n      parentRoute = Yox.array.last(routeStack),\n\n      path = formatPath(routeOptions.path, parentPath),\n\n      route: routerType.LinkedRoute = { path, component, route: routeOptions },\n\n      params: string[] = []\n\n      Yox.array.each(\n        path.split(constant.SEPARATOR_PATH),\n        function (item) {\n          if (Yox.string.startsWith(item, constant.PREFIX_PARAM)) {\n            params.push(\n              item.substr(constant.PREFIX_PARAM.length)\n            )\n          }\n        }\n      )\n\n      if (params.length) {\n        route.params = params\n      }\n\n      if (parentRoute) {\n        route.parent = parentRoute\n      }\n\n      if (children) {\n        pathStack.push(path)\n        routeStack.push(route)\n        Yox.array.each(\n          children,\n          callback\n        )\n        routeStack.pop()\n        pathStack.pop()\n      }\n      else {\n\n        instance.routes.push(route)\n\n        if (name) {\n          if (process.env.NODE_ENV === 'development') {\n            if (Yox.object.has(instance.name2Path, name)) {\n              Yox.logger.error(`Name[${name}] of the route is existed.`)\n              return\n            }\n          }\n          instance.name2Path[name] = path\n        }\n\n        if (process.env.NODE_ENV === 'development') {\n          if (Yox.object.has(instance.path2Route, path)) {\n            Yox.logger.error(`path [${path}] of the route is existed.`)\n            return\n          }\n        }\n\n        instance.path2Route[path] = route\n\n      }\n\n    }\n\n    Yox.array.each(\n      routes,\n      callback\n    )\n\n  }\n\n  /**\n   * 真正执行路由切换操作的函数\n   *\n   * target 有 2 种格式：\n   *\n   * 如果只是简单的 path，直接传字符串\n   *\n   * push('/index')\n   *\n   * 如果需要带参数，可传对象\n   *\n   * push({\n   *   path: '/index',\n   *   params: { },\n   *   query: { }\n   * })\n   *\n   * 如果路由配置了 name，可用 name 代替 path，如下：\n   *\n   * push({\n   *   name: 'index'\n   * })\n   *\n   */\n  push(target: routerType.Target) {\n\n    const instance = this,\n\n    location = instance.setLocation(\n      toLocation(target, instance.name2Path),\n      function () {\n        instance.pushHistory(location as routerType.Location)\n      },\n      env.EMPTY_FUNCTION\n    )\n\n    if (location) {\n      instance.setHash(location)\n    }\n\n  }\n\n  replace(target: routerType.Target) {\n\n    const instance = this,\n\n    location = instance.setLocation(\n      toLocation(target, instance.name2Path),\n      function () {\n        instance.replaceHistory(location as routerType.Location)\n      },\n      env.EMPTY_FUNCTION\n    )\n\n    if (location) {\n      instance.setRoute(location)\n    }\n\n  }\n\n  go(offset: number) {\n\n    let instance = this,\n\n    cursor = instance.cursor + offset,\n\n    location: routerType.Location | void = instance.history[cursor]\n\n    if (location) {\n      location = instance.setLocation(\n        location,\n        function () {\n          instance.cursor = cursor\n        },\n        env.EMPTY_FUNCTION\n      )\n      if (location) {\n        instance.setHash(location)\n      }\n    }\n\n  }\n\n  /**\n   * 启动路由\n   */\n  start() {\n    domApi.on(WINDOW, EVENT_HASH_CHANGE, this.onHashChange as type.listener)\n    this.onHashChange()\n  }\n\n  /**\n   * 停止路由\n   */\n  stop() {\n    domApi.off(WINDOW, EVENT_HASH_CHANGE, this.onHashChange as type.listener)\n  }\n\n  /**\n   * 钩子函数\n   */\n  hook(route: routerType.LinkedRoute, componentHook: string, hook: string, isGuard?: boolean, callback?: routerType.Callback) {\n\n    const instance = this, { location, hooks, loading } = instance\n\n    hooks\n      .clear()\n      // 先调用组件的钩子\n      .add(route.component[componentHook], route.context)\n      // 再调用路由配置的钩子\n      .add(route.route[hook], route.route)\n      // 最后调用路由实例的钩子\n      .add(instance[hook], instance)\n\n    const next = function (value?: false | routerType.Target) {\n      if (value === env.UNDEFINED) {\n        hooks.next(next, isGuard, callback)\n      }\n      else {\n        // 只有前置守卫才有可能走进这里\n        // 此时 instance.location 还是旧地址\n        if (loading) {\n          loading.onAbort()\n          instance.loading = env.UNDEFINED\n        }\n        if (value === env.FALSE) {\n          if (location) {\n            instance.push(location)\n          }\n        }\n        else {\n          // 跳转到别的路由\n          instance.push(value)\n        }\n      }\n    }\n\n    next()\n\n  }\n\n  private pushHistory(location: routerType.Location) {\n    let { history, cursor } = this\n    cursor++\n    // 确保下一个为空\n    // 如果不为空，肯定是调用过 go()，此时直接清掉后面的就行了\n    if (history[cursor]) {\n      history.length = cursor\n    }\n    history[cursor] = location\n    this.cursor = cursor\n  }\n\n  private replaceHistory(location: routerType.Location) {\n    const { history, cursor } = this\n    if (history[cursor]) {\n      history[cursor] = location\n    }\n  }\n\n  private setHash(location: routerType.Location) {\n\n    const hash = constant.PREFIX_HASH + location.hash\n    if (LOCATION.hash !== hash) {\n      LOCATION.hash = hash\n    }\n    else {\n      this.setRoute(location)\n    }\n\n  }\n\n  private setLocation(\n    location: routerType.Location,\n    onComplete: routerType.RouteComplete,\n    onAbort: routerType.RouteAbort\n  ) {\n\n    let instance = this,\n\n    hash = locationUtil.stringify(Yox, location),\n\n    oldLocation = instance.location,\n\n    oldHash = oldLocation ? locationUtil.stringify(Yox, oldLocation) : env.UNDEFINED,\n\n    existed = locationUtil.parse(Yox, instance.routes, hash)\n\n    if (existed) {\n      location = existed\n    }\n    else {\n      hash = instance.route404.path\n      location = {\n        hash,\n        path: hash\n      }\n    }\n\n    if (hash !== oldHash) {\n      instance.loading = {\n        location,\n        onComplete,\n        onAbort,\n      }\n      return location\n    }\n\n  }\n\n  private diffRoute(\n    route: routerType.LinkedRoute,\n    oldRoute: routerType.LinkedRoute | void,\n    onComplete: routerType.DiffComplete,\n    startRoute: routerType.LinkedRoute | void,\n    childRoute: routerType.LinkedRoute | void,\n    oldTopRoute: routerType.LinkedRoute | void\n  ) {\n\n    // 更新链路\n    if (childRoute) {\n      route.child = childRoute\n      childRoute.parent = route\n    }\n\n    if (oldRoute) {\n      // 同级的两个组件不同，疑似起始更新的路由\n      if (oldRoute.component !== route.component) {\n        startRoute = route\n      }\n      else {\n        // 把上次的组件实例搞过来\n        route.context = oldRoute.context\n      }\n    }\n    else {\n      startRoute = route\n    }\n\n    if (route.parent) {\n      this.diffRoute(\n        Yox.object.copy(route.parent),\n        oldRoute ? oldRoute.parent : env.UNDEFINED,\n        onComplete,\n        startRoute,\n        route,\n        oldRoute || oldTopRoute\n      )\n      return\n    }\n\n    // 整个组件树全换掉\n    if (startRoute === route) {\n      let context: Yox | void\n      // 当层级较多的路由切换到层级较少的路由\n      if (oldRoute) {\n        while (oldRoute) {\n          context = oldRoute.context\n          oldRoute = oldRoute.parent\n        }\n      }\n      // 当层级较少的路由切换到层级较多的路由\n      else if (oldTopRoute) {\n        context = oldTopRoute.context\n      }\n      if (context) {\n        startRoute.context = context\n      }\n    }\n\n    // 到达根组件，结束\n    onComplete(route, startRoute)\n\n  }\n\n  private patchRoute(\n    route: routerType.LinkedRoute,\n    startRoute: routerType.LinkedRoute | void\n  ) {\n\n    const instance = this, location = instance.location as routerType.Location\n\n    // 从上往下更新 props\n    while (route) {\n\n      let { parent, context, component } = route\n\n      if (route === startRoute) {\n\n        if (parent) {\n\n          context = parent.context as Yox\n          context.forceUpdate(\n            filterProps(\n              parent,\n              location,\n              parent.component\n            )\n          )\n\n          context = context[ROUTE_VIEW]\n          if (context) {\n            const props = {}, name = ROUTE_COMPONENT + (++guid)\n            props[ROUTE_COMPONENT] = name\n            context.component(name, component)\n            context.forceUpdate(props)\n          }\n\n        }\n        else {\n\n          if (context) {\n            context.destroy()\n          }\n\n          // 每层路由组件都有 $route 和 $router 属性\n          const extensions = {}\n          extensions[ROUTER] = instance\n          extensions[ROUTE] = route\n\n          route.context = new Yox(\n            Yox.object.extend(\n              {\n                el: instance.el,\n                props: filterProps(route, location, component),\n                extensions,\n              },\n              component\n            )\n          )\n\n        }\n\n      }\n\n      else if (context) {\n        if (context.$vnode) {\n          context[ROUTE] = route\n          context.forceUpdate(\n            filterProps(route, location, component)\n          )\n        }\n        else {\n          route.context = env.UNDEFINED\n        }\n        if (route.child) {\n          route = route.child as routerType.LinkedRoute\n          continue\n        }\n      }\n      break\n    }\n  }\n\n  private setRoute(location: routerType.Location) {\n\n    let instance = this,\n\n    linkedRoute = instance.path2Route[location.path],\n\n    redirect = linkedRoute.route.redirect\n\n    if (redirect) {\n      if (Yox.is.func(redirect)) {\n        redirect = (redirect as routerType.Redirect)(location)\n      }\n      if (redirect) {\n        instance.push(redirect as routerType.Target)\n        return\n      }\n    }\n\n    const newRoute = Yox.object.copy(linkedRoute),\n\n    oldRoute = instance.route,\n\n    oldLocation = instance.location,\n\n    enterRoute = function () {\n      instance.diffRoute(\n        newRoute,\n        oldRoute,\n        function (route, startRoute) {\n          instance.hook(\n            newRoute,\n            startRoute ? constant.HOOK_BEFORE_ROUTE_ENTER : constant.HOOK_BEFORE_ROUTE_UPDATE,\n            startRoute ? constant.HOOK_BEFORE_ENTER : constant.HOOK_BEFORE_UPDATE,\n            env.TRUE,\n            function () {\n\n              instance.route = newRoute\n              instance.location = location\n\n              instance.patchRoute(route, startRoute)\n\n            }\n          )\n        }\n      )\n    }\n\n    instance.hooks.setLocation(location, oldLocation)\n\n    if (oldRoute && oldLocation && location.path !== oldLocation.path) {\n      instance.hook(\n        oldRoute,\n        constant.HOOK_BEFORE_ROUTE_LEAVE,\n        constant.HOOK_BEFORE_LEAVE,\n        env.TRUE,\n        enterRoute\n      )\n      return\n    }\n\n    enterRoute()\n\n  }\n\n}\n\nconst directive = {\n  bind(node: HTMLElement | Yox, directive: Directive, vnode: VNode) {\n\n    // 当前组件如果是根组件，则没有 $root 属性\n    const $root = vnode.context.$root || vnode.context,\n\n    router = $root[ROUTER] as Router,\n\n    listener = vnode.data[directive.key] = function (_: CustomEvent) {\n      let { value, getter } = directive, target: any = value\n      if (value && getter && Yox.string.has(value as string, '{')) {\n        target = getter()\n      }\n      router[directive.name](target)\n    }\n\n    if (vnode.isComponent) {\n      (node as Yox).on(EVENT_CLICK, listener)\n    }\n    else {\n      domApi.on(node as HTMLElement, EVENT_CLICK, listener)\n    }\n\n  },\n  unbind(node: HTMLElement | Yox, directive: Directive, vnode: VNode) {\n    const listener = vnode.data[directive.key]\n    if (vnode.isComponent) {\n      (node as Yox).off(EVENT_CLICK, listener)\n    }\n    else {\n      domApi.off(node as HTMLElement, EVENT_CLICK, listener)\n    }\n  },\n},\n\nRouterView: YoxOptions = {\n  template: '<$' + ROUTE_COMPONENT + '/>',\n  beforeCreate(options) {\n\n    const $parent = options.parent as Yox,\n\n    route = $parent[ROUTE].child as routerType.LinkedRoute\n\n    if (route) {\n\n      $parent[ROUTE_VIEW] = this\n\n      const props = options.props = {},\n\n      components = options.components = {},\n\n      name = ROUTE_COMPONENT + (++guid)\n\n      props[ROUTE_COMPONENT] = name\n      components[name] = route.component\n\n    }\n\n  },\n  beforeDestroy() {\n    this.$parent[ROUTE_VIEW] = env.UNDEFINED\n  }\n}\n\n/**\n * 版本\n */\nexport const version = process.env.NODE_VERSION\n\n/**\n * 安装插件\n */\nexport function install(Class: YoxClass): void {\n\n  Yox = Class\n  domApi = Class.dom as API\n\n  Yox.directive({\n    push: directive,\n    replace: directive,\n  })\n\n  Yox.component('router-view', RouterView)\n\n  const { beforeCreate, afterMount, afterUpdate, afterDestroy } = Yox\n\n  Yox.beforeCreate = function (options) {\n\n    if (beforeCreate) {\n      beforeCreate(options)\n    }\n\n    let { parent } = options\n\n    // 处理 <router-view> 嵌入的组件\n    if (parent && options.beforeCreate !== RouterView.beforeCreate) {\n\n      // parent 是 <router-view> 实例，得再上一层才是路由组件\n      parent = parent.$parent\n      if (parent) {\n        const router = parent[ROUTER] as Router,\n        route = parent[ROUTE].child as routerType.LinkedRoute\n\n        if (router && route) {\n          const extensions = options.extensions = {}\n\n          extensions[ROUTER] = router\n          extensions[ROUTE] = route\n\n          if (router.location) {\n            options.props = filterProps(route, router.location, options)\n          }\n        }\n      }\n\n    }\n  }\n\n  Yox.afterMount = function (instance) {\n\n    if (afterMount) {\n      afterMount(instance)\n    }\n\n    updateRoute(instance, constant.HOOK_AFTER_ROUTE_ENTER, constant.HOOK_AFTER_ENTER, env.TRUE)\n\n  }\n  Yox.afterUpdate = function (instance) {\n\n    if (afterUpdate) {\n      afterUpdate(instance)\n    }\n\n    updateRoute(instance, constant.HOOK_AFTER_ROUTE_UPDATE, constant.HOOK_AFTER_UPDATE, env.TRUE)\n\n  }\n  Yox.afterDestroy = function (instance) {\n\n    if (afterDestroy) {\n      afterDestroy(instance)\n    }\n\n    updateRoute(instance, constant.HOOK_AFTER_ROUTE_LEAVE, constant.HOOK_AFTER_LEAVE)\n\n  }\n\n}\n"],"names":["const","TRUE","FALSE","NULL","UNDEFINED","RAW_TRUE","RAW_FALSE","RAW_NULL","RAW_UNDEFINED","EMPTY_FUNCTION","EMPTY_STRING","Object","freeze","Hooks","to","from","this","list","hook","ctx","push","fn","next","isGuard","callback","task","shift","call","PREFIX_HASH","PREFIX_PARAM","SEPARATOR_PATH","SEPARATOR_SEARCH","SEPARATOR_QUERY","SEPARATOR_PAIR","FLAG_ARRAY","HOOK_AFTER_ENTER","HOOK_AFTER_ROUTE_ENTER","HOOK_AFTER_UPDATE","HOOK_AFTER_ROUTE_UPDATE","HOOK_AFTER_LEAVE","HOOK_AFTER_ROUTE_LEAVE","parse","Yox","value","result","is","numeric","string","env.RAW_TRUE","env.TRUE","env.RAW_FALSE","env.FALSE","env.RAW_NULL","env.NULL","env.RAW_UNDEFINED","env.UNDEFINED","decodeURIComponent","stringify","encodeURIComponent","number","boolean","toString","routes","hash","realpath","search","index","indexOf","constant.SEPARATOR_SEARCH","slice","route","realpathTerms","split","constant.SEPARATOR_PATH","length","i","loop","params","pathTerms","path","l","startsWith","constant.PREFIX_PARAM","getRouteByRealpath","array","each","item","substr","valueUtil.parse","parseParams","query","constant.SEPARATOR_QUERY","term","terms","constant.SEPARATOR_PAIR","key","trim","endsWith","constant.FLAG_ARRAY","queryUtil.parse","location","join","queryStr","valueUtil.stringify","queryUtil.stringify","domApi","guid","WINDOW","window","LOCATION","ROUTER","ROUTE","formatPath","parentPath","toLocation","target","name2Path","env.EMPTY_STRING","name","filterProps","options","propTypes","props","routeParams","locationParams","object","copy","checkProp","updateRoute","instance","componentHook","upsert","context","child","isLeafRoute","router","loading","onComplete","el","route404","find","onHashChange","hashStr","constant.PREFIX_HASH","setRoute","locationUtil.parse","pushHistory","path2Route","history","cursor","hooks","add","last","Router","pathStack","routeStack","routeOptions","component","children","parentRoute","parent","pop","setLocation","env.EMPTY_FUNCTION","setHash","replaceHistory","offset","on","off","clear","onAbort","locationUtil.stringify","oldLocation","oldHash","existed","oldRoute","startRoute","childRoute","oldTopRoute","diffRoute","forceUpdate","destroy","extensions","extend","$vnode","linkedRoute","redirect","func","newRoute","enterRoute","patchRoute","directive","bind","node","vnode","$root","listener","data","_","getter","has","isComponent","unbind","RouterView","template","beforeCreate","$parent","components","beforeDestroy","Class","dom","replace","afterMount","afterUpdate","afterDestroy","constant.HOOK_AFTER_ROUTE_ENTER","constant.HOOK_AFTER_ENTER","constant.HOOK_AFTER_ROUTE_UPDATE","constant.HOOK_AFTER_UPDATE","constant.HOOK_AFTER_ROUTE_LEAVE","constant.HOOK_AFTER_LEAVE"],"mappings":"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"}