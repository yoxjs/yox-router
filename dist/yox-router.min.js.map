{"version":3,"file":"yox-router.min.js","sources":["../src/index.ts"],"sourcesContent":["import * as type from 'yox-type/src/type'\n\nimport API from 'yox-type/src/interface/API'\nimport Yox from 'yox-type/src/interface/Yox'\nimport YoxClass from 'yox-type/src/interface/YoxClass'\nimport Task from 'yox-type/src/interface/Task'\nimport YoxOptions from 'yox-type/src/options/Yox';\n\nlet Yox: YoxClass, store: Yox, domApi: API\n\nconst UNDEFINED = void 0,\n\n// hash 前缀，Google 的规范是 #! 开头，如 #!/path/sub?key=value\nPREFIX_HASH = '#!',\n\n// path 中的参数前缀，如 #!/user/:userId\nPREFIX_PARAM = ':',\n\n// path 分隔符\nSEPARATOR_PATH = '/',\n\n// query 分隔符\nSEPARATOR_QUERY = '&',\n\n// 键值对分隔符\nSEPARATOR_PAIR = '=',\n\n// 参数中的数组标识\nFLAG_ARRAY = '[]',\n\n// 默认路由\nROUTE_DEFAULT = '',\n\n// 404 路由\nROUTE_404 = '*',\n\n// 导航钩子 - 如果相继路由到的是同一个组件，那么会触发 refreshing 事件\nHOOK_REFRESHING = 'refreshing',\n\n// 导航钩子 - 路由进入之前\nHOOK_BEFORE_ENTER = 'beforeEnter',\n\n// 导航钩子 - 路由进入之后\nHOOK_AFTER_ENTER = 'afterEnter',\n\n// 导航钩子 - 路由离开之前\nHOOK_BEFORE_LEAVE = 'beforeLeave',\n\n// 导航钩子 - 路由离开之后\nHOOK_AFTER_LEAVE = 'afterLeave'\n\ntype PathTarget = string\n\ninterface RouteTarget {\n  name: string\n  params?: type.data\n  query?: type.data\n}\n\ninterface ComponentTarget {\n  component: string\n  props?: type.data\n}\n\ntype Target = PathTarget | RouteTarget | ComponentTarget\n\ntype next = (value?: false | Target) => void\n\ntype success = () => void\n\ntype failure = (value: false | Target) => void\n\ntype BeforeHook = (to: Route, from: Route | void, next: next) => void\n\ntype AfterHook = (to: Route, from: Route | void) => void\n\ninterface RouterOptions {\n  routes: RouteOptions[]\n}\n\ninterface RouteOptions {\n  path: string,\n  component: string\n  name?: string\n  [HOOK_REFRESHING]?: BeforeHook\n  [HOOK_BEFORE_ENTER]?: BeforeHook\n  [HOOK_AFTER_ENTER]?: AfterHook\n  [HOOK_BEFORE_LEAVE]?: BeforeHook\n  [HOOK_AFTER_LEAVE]?: AfterHook\n}\n\ninterface Route {\n  component: string\n  props?: type.data\n  path?: string\n  params?: type.data\n  query?: type.data\n}\n\ninterface Component {\n  name: string\n  root?: Yox\n  options?: YoxOptions\n}\n\ninterface Hash {\n  realpath: string\n  route?: RouteOptions\n  params?: type.data\n  query?: type.data\n}\n\n/**\n * 把字符串 value 解析成最合适的类型\n */\nfunction parseValue(value: string) {\n  let result: any\n  if (Yox.is.numeric(value)) {\n    result = +value\n  }\n  else if (Yox.is.string(value)) {\n    if (value === 'true') {\n      result = true\n    }\n    else if (value === 'false') {\n      result = false\n    }\n    else if (value === 'null') {\n      result = null\n    }\n    else if (value === 'undefined') {\n      result = UNDEFINED\n    }\n    else {\n      result = decodeURIComponent(value)\n    }\n  }\n  return result\n}\n\n/**\n * 把 key value 序列化成合适的 key=value 格式\n */\nfunction stringifyPair(key: string, value: any) {\n  let result = [key]\n  if (Yox.is.string(value)) {\n    result.push(\n      encodeURIComponent(value)\n    )\n  }\n  else if (Yox.is.number(value) || Yox.is.boolean(value)) {\n    result.push(\n      value.toString()\n    )\n  }\n  else if (value === null) {\n    result.push(\n      'null'\n    )\n  }\n  else if (value === UNDEFINED) {\n    result.push(\n      'undefined'\n    )\n  }\n  return result.join(SEPARATOR_PAIR)\n}\n\n/**\n * 把 GET 参数解析成对象\n */\nfunction parseQuery(query: string) {\n  let result: Object | undefined\n  Yox.array.each(\n    query.split(SEPARATOR_QUERY),\n    function (term) {\n\n      let terms = term.split(SEPARATOR_PAIR),\n\n      key = Yox.string.trim(terms[0]),\n\n      value = terms[1]\n\n      if (key) {\n        if (!result) {\n          result = {}\n        }\n        value = parseValue(value)\n        if (Yox.string.endsWith(key, FLAG_ARRAY)) {\n          key = Yox.string.slice(key, 0, -FLAG_ARRAY.length)\n          Yox.array.push(\n            result[key] || (result[key] = []),\n            value\n          )\n        }\n        else {\n          result[key] = value\n        }\n      }\n\n    }\n  )\n  return result\n}\n\n/**\n * 把对象解析成 key1=value1&key2=value2\n */\nfunction stringifyQuery(query: Object) {\n  const result: string[] = []\n  Yox.object.each(\n    query,\n    function (value, key) {\n      if (Yox.is.array(value)) {\n        Yox.array.each(\n          value,\n          function (value) {\n            result.push(\n              stringifyPair(key + FLAG_ARRAY, value)\n            )\n          }\n        )\n      }\n      else {\n        result.push(\n          stringifyPair(key, value)\n        )\n      }\n    }\n  )\n  return result.join(SEPARATOR_QUERY)\n}\n\n/**\n * 解析 path 中的参数\n */\nfunction parseParams(realpath: string, path: string) {\n\n  let result: Object | undefined,\n\n  realpathTerms = realpath.split(SEPARATOR_PATH),\n\n  pathTerms = path.split(SEPARATOR_PATH)\n\n  if (realpathTerms.length === pathTerms.length) {\n    Yox.array.each(\n      pathTerms,\n      function (item, index) {\n        if (Yox.string.startsWith(item, PREFIX_PARAM)) {\n          if (!result) {\n            result = {}\n          }\n          result[item.substr(PREFIX_PARAM.length)] = parseValue(realpathTerms[index])\n        }\n      }\n    )\n  }\n\n  return result\n\n}\n\n/**\n * 通过 realpath 获取配置的路由\n */\nfunction getRouteByRealpath(routes: RouteOptions[], realpath: string) {\n\n  let result: RouteOptions | undefined,\n\n  realpathTerms = realpath.split(SEPARATOR_PATH),\n\n  length = realpathTerms.length\n\n  Yox.array.each(\n    routes,\n    function (route) {\n      const pathTerms = route.path.split(SEPARATOR_PATH)\n      if (length === pathTerms.length) {\n        for (let i = 0; i < length; i++) {\n          // 非参数段不相同\n          if (!Yox.string.startsWith(pathTerms[i], PREFIX_PARAM)\n            && pathTerms[i] !== realpathTerms[i]\n          ) {\n            return\n          }\n        }\n        result = route\n        return false\n      }\n    }\n  )\n\n  return result\n\n}\n\n/**\n * 完整解析 hash 数据\n */\nfunction parseHash(routes: RouteOptions[], hash: string) {\n\n  let realpath: string, search: string | void, index = hash.indexOf('?')\n\n  if (index >= 0) {\n    realpath = hash.substring(0, index)\n    search = hash.substring(index + 1)\n  }\n  else {\n    realpath = hash\n  }\n\n  let result: Hash = { realpath }, route = getRouteByRealpath(routes, realpath)\n\n  if (route) {\n    result.route = route\n    const params = parseParams(realpath, route.path)\n    if (params) {\n      result.params = params\n    }\n    if (search) {\n      const query = parseQuery(search)\n      if (query) {\n        result.query = query\n      }\n    }\n  }\n\n  return result\n}\n\n/**\n * 把结构化数据序列化成 hash\n */\nfunction stringifyHash(path: string, params: Object | void, query: Object | void) {\n\n  let terms: string[] = [], realpath: string, search = ''\n\n  Yox.array.each(\n    path.split(SEPARATOR_PATH),\n    function (item) {\n      terms.push(\n        Yox.string.startsWith(item, PREFIX_PARAM)\n          ? params[item.substr(PREFIX_PARAM.length)]\n          : item\n      )\n    }\n  )\n\n  realpath = terms.join(SEPARATOR_PATH)\n\n  if (query) {\n    const queryStr = stringifyQuery(query)\n    if (queryStr) {\n      search = '?' + queryStr\n    }\n  }\n\n  return PREFIX_HASH + realpath + search\n\n}\n\n// 钩子函数的调用链\nclass Chain {\n\n  name: string\n\n  list: Task[]\n\n  constructor(name: string) {\n    this.name = name\n    this.list = []\n  }\n\n  append(target: Object | void, ctx: any) {\n    const { name, list } = this\n    if (target && Yox.is.func(target[name])) {\n      list.push({\n        fn: target[name] as Function,\n        ctx,\n      })\n    }\n    return this\n  }\n\n  run(to: Route, from: Route | void, success: success | void, failure: failure | void) {\n\n    const { list } = this,\n\n    next: next = function (value?: false | Target) {\n      if (value == null) {\n        const task = list.shift()\n        if (task) {\n          task.fn.call(task.ctx, to, from, next)\n        }\n        else if (success) {\n          success()\n        }\n      }\n      else if (failure) {\n        failure(value)\n      }\n    }\n\n    next()\n\n  }\n\n}\n\nexport class Router {\n\n  el?: Element\n\n  routes: RouteOptions[]\n\n  route404: RouteOptions\n\n  routeDefault: RouteOptions\n\n  name2Path: Record<string, string>\n\n  onHashChange: Function\n\n  currentRoute?: Route\n\n  currentComponent?: Component\n\n  [HOOK_REFRESHING]?: BeforeHook\n\n  [HOOK_BEFORE_ENTER]?: BeforeHook\n\n  [HOOK_AFTER_ENTER]?: AfterHook\n\n  [HOOK_BEFORE_LEAVE]?: BeforeHook\n\n  [HOOK_AFTER_LEAVE]?: AfterHook\n\n  constructor(options: RouterOptions) {\n\n    const instance = this\n\n    instance.routes = options.routes\n\n    /**\n     * 路由表 name -> path\n     */\n    instance.name2Path = {}\n\n    /**\n     * hashchange 事件处理函数\n     * 此函数必须写在实例上，不能写在类上\n     * 否则一旦解绑，所有实例都解绑了\n     */\n    instance.onHashChange = function () {\n\n      let hashStr = location.hash\n\n      // 如果不以 PREFIX_HASH 开头，表示不合法\n      hashStr = Yox.string.startsWith(hashStr, PREFIX_HASH)\n        ? hashStr.substr(PREFIX_HASH.length)\n        : ''\n\n      const hash = parseHash(options.routes, hashStr),\n\n      route = hash.route || (hashStr ? instance.route404 : instance.routeDefault)\n\n      instance.setRoute(\n        {\n          component: route.component,\n          path: route.path,\n          params: hash.params,\n          query: hash.query,\n        },\n        route\n      )\n\n    }\n\n    let route404: RouteOptions | undefined, routeDefault: RouteOptions | undefined\n\n    Yox.array.each(\n      options.routes,\n      function (route: RouteOptions) {\n        if (route.name) {\n          instance.name2Path[route.name] = route.path\n        }\n        if (route.path === ROUTE_404) {\n          route404 = route\n        }\n        else if (route.path === ROUTE_DEFAULT) {\n          routeDefault = route\n        }\n      }\n    )\n\n    if (process.env.NODE_ENV === 'dev') {\n      if (!routeDefault) {\n        Yox.logger.error(`Route for default[\"${ROUTE_DEFAULT}\"] is required.`)\n        return\n      }\n      if (!route404) {\n        Yox.logger.error(`Route for 404[\"${ROUTE_404}\"] is required.`)\n        return\n      }\n    }\n\n    instance.route404 = route404 as RouteOptions\n    instance.routeDefault = routeDefault as RouteOptions\n\n  }\n\n  /**\n   * 真正执行路由切换操作的函数\n   *\n   * data 有 2 种格式：\n   *\n   * 1. 会修改 url\n   *\n   * 如果只是简单的 path，直接传字符串\n   *\n   * go('/index')\n   *\n   * 如果需要带参数，切记路由表要配置 name\n   *\n   * go({\n   *   name: 'index',\n   *   params: { },\n   *   query: { }\n   * })\n   *\n   * 如果没有任何参数，可以只传 path\n   *\n   * go('/index')\n   *\n   * 2. 不会改变 url\n   *\n   * go({\n   *   component: 'index',\n   *   props: { }\n   * })\n   *\n   */\n  go(target: Target) {\n    if (Yox.is.string(target)) {\n      location.hash = stringifyHash(target as PathTarget)\n    }\n    else if (Yox.is.object(target)) {\n      if (Yox.object.has(target, 'component')) {\n\n        const { component, props } = target as ComponentTarget\n\n        this.setRoute({\n          component,\n          props,\n        })\n\n      }\n      else if (Yox.object.has(target, 'name')) {\n\n        const { name, params, query } = target as RouteTarget, path = this.name2Path[name]\n\n        if (process.env.NODE_ENV === 'dev') {\n          if (!Yox.is.string(path)) {\n            Yox.logger.error(`Name[${name}] of the route is not found.`)\n            return\n          }\n        }\n\n        location.hash = stringifyHash(path, params, query)\n\n      }\n    }\n  }\n\n  /**\n   * 切换路由\n   */\n  setRoute(route: Route, options?: RouteOptions) {\n\n    let instance = this,\n\n    { currentRoute } = instance,\n\n    { params, query, component, props } = route,\n\n    currentComponent = instance.currentComponent || (instance.currentComponent = { name: component }),\n\n    failure: failure = function (value: false | Target) {\n      if (value === false) {\n        // 流程到此为止，恢复到当前路由\n        if (currentRoute && Yox.is.string(currentRoute.path)) {\n          location.hash = stringifyHash(\n            currentRoute.path as string,\n            currentRoute.params,\n            currentRoute.query\n          )\n        }\n      }\n      else {\n        // 跳转到别的路由\n        instance.go(value)\n      }\n    },\n\n    callHook = function (name: string, success: success | void, failure: failure | void) {\n      new Chain(name)\n      // 先调用组件的钩子\n      .append(currentComponent.options, currentComponent.root)\n      // 再调用路由配置的钩子\n      .append(options, options)\n      // 最后调用路由实例的钩子\n      .append(instance, instance)\n      .run(route, currentRoute, success, failure)\n    },\n\n    createComponent = function (options: YoxOptions) {\n\n      currentComponent.options = options\n\n      callHook(\n        HOOK_BEFORE_ENTER,\n        function () {\n\n          if (params || query) {\n            props = {}\n            if (params) {\n              Yox.object.extend(props, params)\n            }\n            if (query) {\n              Yox.object.extend(props, query)\n            }\n          }\n\n          currentComponent.root = new Yox(\n            Yox.object.extend(\n              {\n                el: instance.el,\n                props,\n                extensions: {\n                  $router: instance,\n                  $route: route,\n                }\n              },\n              options\n            )\n          )\n\n          instance.currentRoute = route\n\n          callHook(HOOK_AFTER_ENTER)\n\n        },\n        failure\n      )\n    },\n\n    changeComponent = function (options: YoxOptions) {\n      callHook(\n        HOOK_BEFORE_LEAVE,\n        function () {\n          if (currentComponent.root) {\n            currentComponent.root.destroy()\n            currentComponent.root = UNDEFINED\n          }\n          callHook(HOOK_AFTER_LEAVE)\n          createComponent(options)\n        },\n        failure\n      )\n    }\n\n    if (currentComponent.name !== component) {\n      currentComponent.name = component\n    }\n\n    store.component(\n      component,\n      function (options: YoxOptions) {\n        // 当连续调用此方法，且可能出现异步组件时\n        // 执行到这 name 不一定会等于 currentComponent.name\n        // 因此需要强制保证一下\n        if (component !== currentComponent.name) {\n          return\n        }\n\n        if (currentComponent.root) {\n          // 当前根组件还活着，并且还要切到当前根组件，表示刷新一下\n          if (currentComponent.options === options) {\n            callHook(\n              HOOK_REFRESHING,\n              function () {\n                // 如果 refreshing 钩子调用了 next()\n                // 表示要销毁重建当前根组件\n                changeComponent(options)\n              },\n              failure\n            )\n          }\n          // 切换到其他组件\n          else {\n            changeComponent(options)\n          }\n        }\n        // 第一次创建组件\n        else {\n          createComponent(options)\n        }\n\n      }\n    )\n\n  }\n\n  /**\n   * 启动路由\n   */\n  start(el: string | Element) {\n    if (Yox.is.string(el)) {\n      const element = domApi.find(el as string)\n      if (element) {\n        this.el = element\n      }\n    }\n    else {\n      this.el = el as Element\n    }\n    domApi.on(window, 'hashchange', this.onHashChange as type.listener)\n    this.onHashChange()\n  }\n\n  /**\n   * 停止路由\n   */\n  stop() {\n    this.el = UNDEFINED\n    domApi.off(window, 'hashchange', this.onHashChange as type.listener)\n  }\n\n}\n\n/**\n * 版本\n */\nexport const version = process.env.NODE_VERSION\n\n/**\n * 注册全局组件，路由实例可共享\n */\nexport function register(\n  name: string | Record<string, type.component>,\n  component?: type.component\n): void {\n  store.component(name, component)\n}\n\n/**\n * 安装插件\n */\nexport function install(Class: YoxClass): void {\n  Yox = Class\n  store = new Class()\n  domApi = Class.dom as API\n}\n"],"names":["Yox","store","domApi","UNDEFINED","PREFIX_HASH","PREFIX_PARAM","SEPARATOR_PATH","SEPARATOR_QUERY","SEPARATOR_PAIR","FLAG_ARRAY","ROUTE_DEFAULT","ROUTE_404","parseValue","value","result","is","numeric","string","decodeURIComponent","stringifyPair","key","push","encodeURIComponent","number","boolean","toString","join","parseHash","routes","hash","realpath","search","index","indexOf","substring","route","realpathTerms","split","length","array","each","pathTerms","path","i","startsWith","getRouteByRealpath","params","item","substr","parseParams","query","term","terms","trim","endsWith","slice","parseQuery","stringifyHash","queryStr","object","stringifyQuery","name","this","list","Chain","target","ctx","func","fn","to","from","success","failure","next","task","shift","call","options","route404","routeDefault","instance","name2Path","onHashChange","hashStr","location","setRoute","component","Router","has","_a","props","_b","currentRoute","currentComponent","go","callHook","append","root","run","createComponent","extend","el","extensions","$router","$route","changeComponent","destroy","element","find","on","window","off","Class","dom"],"mappings":"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"}